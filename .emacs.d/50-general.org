#+TITLE: General

* Header
Enable lexical binding. When visiting the tangled file, enable read
only mode.

#+BEGIN_SRC emacs-lisp
  ;;; 50-general.el --- General configuration -*- lexical-binding: t; buffer-read-only: t; -*-

  ;;; Commentary:

  ;; General configuration, part of Koekelas' Emacs configuration.

  ;;; Code:
#+END_SRC

Declare variables and functions setup by [[file:init.el][init.el]].

#+BEGIN_SRC emacs-lisp
  (defvar no-littering-etc-directory)
  (defvar no-littering-var-directory)
  (declare-function no-littering-expand-var-file-name "no-littering")
#+END_SRC

* Files

** projectile - Projects
[[https://github.com/bbatsov/projectile][projectile (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (setq projectile-completion-system 'ivy)
    (projectile-mode)
    :delight)
#+END_SRC

** magit - Git
[[https://github.com/magit/magit][magit (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    ("C-c f g" . magit-status)
    :preface
    (defun koek-git/check-spelling (force)
      "Check spelling of commit message."
      (if git-commit-mode
          (let ((ispell-skip-region-alist ; Looked up dynamically
                 (cons `(,(rx line-start "#") forward-line) ; Single line comment
                       ispell-skip-region-alist))
                (tick (buffer-chars-modified-tick)))
            (ispell-buffer)
            (or force
                (= (buffer-chars-modified-tick) tick) ; No corrections made
                (y-or-n-p "Spelling checked.  Commit? ")))
        t))
    :config
    (add-hook 'with-editor-finish-query-functions #'koek-git/check-spelling))
#+END_SRC

** ediff - Compare files
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :bind
    (("C-c f d" . ediff-files)
     ("C-c f b" . ediff-current-file))
    :preface
    (declare-function outline-show-all "outline")

    (defun koek-diff/unfold-outline ()
      "Unfold outline in outline and derived modes."
      (when (derived-mode-p 'outline-mode) ; org is derived from outline
        (outline-show-all)))
    :config
    (declare-function ediff-setup-windows-plain "ediff-wind")

    ;; Setup restore window layout on quit
    (let (last-layout)
      ;; Store window layout before it's modified. Control buffer
      ;; doesn't exist yet.
      (add-hook 'ediff-before-setup-hook
                (lambda ()
                  (setq last-layout (current-window-configuration))))
      ;; Store window layout in a local hook of control buffer. Current
      ;; is control buffer.
      (add-hook 'ediff-mode-hook
                (lambda ()
                  (let ((layout last-layout))
                    ;; Restore window layout on quit
                    (add-hook 'ediff-quit-hook
                              (lambda ()
                                (set-window-configuration layout))
                              'append 'local)))))

    (setq ediff-window-setup-function #'ediff-setup-windows-plain)
    (setq ediff-split-window-function #'split-window-horizontally)
    (add-hook 'ediff-prepare-buffer-hook #'koek-diff/unfold-outline))
#+END_SRC

** autorevert - Revert file on external change
#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :config
    (global-auto-revert-mode)
    :delight auto-revert-mode)
#+END_SRC

** recentf - Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (mapc (apply-partially #'add-to-list 'recentf-exclude)
          (list "/share/emacs/"
                (expand-file-name (locate-user-emacs-file "elpa/"))
                no-littering-etc-directory
                no-littering-var-directory))
    (recentf-mode))
#+END_SRC

** Auto save files
Save auto-save files in ~/.emacs.d/var/auto-save/.

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+END_SRC

* Editor

** swiper - isearch replacement
[[https://github.com/abo-abo/swiper][swiper (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind
    (([remap isearch-forward] . swiper)
     :map swiper-map
     ("C-c j" . swiper-avy)))
#+END_SRC

** avy - Jump to visible position
[[https://github.com/abo-abo/avy][avy (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    (("C-c j j" . avy-goto-char-timer)
     ([remap goto-line] . avy-goto-line)
     :map org-mode-map
     ;; Lazy loading requires key to be bound here
     ("C-c j h" . avy-org-goto-heading-timer))
    :preface
    (defvar org-mode-map)
    :config
    (setq avy-all-windows nil)
    (setq avy-all-windows-alt 'all-frames)
    (setq avy-keys '(?q ?s ?d ?f ?j ?k ?l ?m))
    (setq avy-dispatch-alist nil))
#+END_SRC

*** link-hint - Jump to visible link
[[https://github.com/noctuid/link-hint.el][link-hint (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :ensure t
    :bind
    ("C-c j l" . link-hint-open-link))
#+END_SRC

** Jump to recent mark positions
When popping mark, skip consecutive identical marks.

#+BEGIN_SRC emacs-lisp
  (define-advice pop-to-mark-command (:around (f) koek-mark/ensure-move)
    (let ((start (point))
          (n (length mark-ring))) ; mark-ring doesn't contain last popped mark
      (funcall f)
      (while (and (= (point) start) (> n 0))
        (funcall f)
        (setq n (1- n)))))
#+END_SRC

When last command was pop mark, press ~C-SPC~ to repeat it.

#+BEGIN_SRC emacs-lisp
  (setq set-mark-command-repeat-pop t)
#+END_SRC

** subword - Recognize words in camel case words
#+BEGIN_SRC emacs-lisp
  (use-package subword
    :init
    (add-hook 'prog-mode-hook #'subword-mode)
    :delight)
#+END_SRC

** Word motion commands
Complement word motion commands. Unlike =forward-to-word= and
=backward-to-word=, =koek-mtn/next-word= and =koek-mtn/previous-word=
recognize [[*subword - Recognize words in camel case words][subwords]].

#+BEGIN_SRC emacs-lisp
  (defun koek-mtn/next-word (&optional arg)
    "Move point to beginning of next word, repeat ARG times.
  Optional ARG is an integer and defaults to one.  When ARG is
  negative, move point to ending of previous word."
    (interactive "p")
    (unless arg
      (setq arg 1))
    (unless (= arg 0)
      (let ((step (/ arg (abs arg))))
        (when (or (and (> step 0) (looking-at (rx word)))
                  (and (< step 0)
                       (looking-back (rx word) (max (1- (point)) (point-min)))))
          (forward-word step))
        (forward-word (- arg step))
        (when (forward-word step)
          (backward-word step)))))

  (defun koek-mtn/previous-word (&optional arg)
    "Move point to ending of previous word, repeat ARG times.
  Optional ARG is an integer and defaults to one.  When ARG is
  negative, move point to beginning of next word."
    (interactive "p")
    (unless arg
      (setq arg 1))
    (koek-mtn/next-word (- arg)))

  (bind-key "M-n" #'koek-mtn/next-word)
  (bind-key "M-p" #'koek-mtn/previous-word)
#+END_SRC

** auto-fill-mode - Break long sentences
#+BEGIN_SRC emacs-lisp
  (defconst koek-af/excluded-modes
    '(snippet-mode)
    "List of major mode symbols, see `koek-af/maybe-enable'.")

  (defun koek-af/maybe-enable ()
    "Enable `auto-fill-mode' conditionally.
  Unless current major mode is member of `koek-af/excluded-modes',
  enable `auto-fill-mode'."
    (unless (memq major-mode koek-af/excluded-modes)
      (auto-fill-mode)))

  (add-hook 'text-mode-hook #'koek-af/maybe-enable)
  (delight 'auto-fill-function nil 'emacs)
#+END_SRC

** smartparens - Pairs & expressions
[[https://github.com/Fuco1/smartparens][smartparens (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :bind
    (("C-M-{" . beginning-of-defun)
     ("C-M-}" . end-of-defun)
     ("C-S-w" . append-next-kill)
     :map smartparens-mode-map
     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)
     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)
     ("C-M-d" . sp-down-sexp)
     ("C-M-u" . sp-up-sexp)
     ("C-S-d" . sp-backward-down-sexp)
     ("C-S-u" . sp-backward-up-sexp)
     ("C-M-<right>" . sp-forward-slurp-sexp)
     ("C-M-<left>"  . sp-forward-barf-sexp)
     ("C-S-<left>"  . sp-backward-slurp-sexp)
     ("C-S-<right>" . sp-backward-barf-sexp)
     ("C-M-<down>"  . sp-unwrap-sexp)
     ("C-M-t" . sp-transpose-sexp)
     ("C-M-w" . sp-copy-sexp)
     ("C-M-k" . sp-kill-sexp))
    :init
    (add-hook 'prog-mode-hook #'smartparens-mode)
    :config
    (require 'smartparens-config)
    (setq sp-navigate-interactive-always-progress-point t)
    (add-hook 'smartparens-mode-hook #'show-smartparens-mode)
    :delight)
#+END_SRC

** expand-region - Mark increasingly larger unit
[[https://github.com/magnars/expand-region.el][expand-region (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind
    ("C-S-SPC" . er/expand-region))
#+END_SRC

** Whitespace
Indent with spaces, not tabs.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

End sentences with single space, not double space.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

End files with empty line.

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)

  (defun koek-ws/disable-final-empty-line ()
    "Disable final empty line for current."
    (setq-local require-final-newline nil))
#+END_SRC

** whitespace - Clean & visualize whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :init
    (add-hook 'prog-mode-hook #'whitespace-mode)
    :config
    (setq whitespace-style
          '(space-mark tab-mark newline-mark
            face spaces tabs newline trailing empty lines-tail))
    (setq whitespace-display-mappings
          '((space-mark   ?\    [?·])
            (space-mark   ?\xA0 [?¤])
            (tab-mark     ?\t   [?⇥ ?\t])
            (newline-mark ?\n   [?↵ ?\n])))
    (add-hook 'before-save-hook #'whitespace-cleanup)
    :delight)
#+END_SRC

** Complete text
When line is indented, press ~TAB~ to complete text before point.

#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC

** yasnippet - Snippets
[[https://github.com/joaotavora/yasnippet][yasnippet (GitHub)]]

For the major mode, see [[*YASnippet][YASnippet]].

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :preface
    (declare-function yas-reload-all "yasnippet")
    :init
    (dolist (hook '(text-mode-hook prog-mode-hook))
      (add-hook hook #'yas-minor-mode))
    :config
    ;; Load own snippets
    (setq yas-snippet-dirs (delq 'yas-installed-snippets-dir yas-snippet-dirs))
    (yas-reload-all)

    ;; Set new snippet file snippet
    (with-temp-buffer
      (insert-file-contents
       (expand-file-name "yasnippet/snippets/snippet-mode/new"
                         no-littering-etc-directory))
      (setq yas-new-snippet-default
            (buffer-substring (re-search-forward (rx line-start "# --\n"))
                              (point-max))))
    :delight yas-minor-mode)
#+END_SRC

** ispell - Spell checker
#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :config
    (setq ispell-program-name (executable-find "hunspell"))
    (let ((dictionary-name "en_US"))
      ;; Hunspell on Windows requires DICTIONARY environment variable to
      ;; be set
      (when (eq system-type 'windows-nt)
        (setenv "DICTIONARY" dictionary-name))
      (setq ispell-dictionary dictionary-name)))
#+END_SRC

** flycheck - Show syntax & style errors
[[https://github.com/flycheck/flycheck][flycheck (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'flycheck-mode)
    :delight)
#+END_SRC

* Windows & buffers

** eyebrowse - Workspaces
[[https://github.com/wasamasa/eyebrowse][eyebrowse (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :ensure t
    :bind
    (("C-c w 0" . eyebrowse-switch-to-window-config-0)
     ("C-c w 1" . eyebrowse-switch-to-window-config-1)
     ("C-c w 2" . eyebrowse-switch-to-window-config-2)
     ("C-c w 3" . eyebrowse-switch-to-window-config-3)
     ("C-c w 4" . eyebrowse-switch-to-window-config-4)
     ("C-c w 5" . eyebrowse-switch-to-window-config-5)
     ("C-c w 6" . eyebrowse-switch-to-window-config-6)
     ("C-c w 7" . eyebrowse-switch-to-window-config-7)
     ("C-c w 8" . eyebrowse-switch-to-window-config-8)
     ("C-c w 9" . eyebrowse-switch-to-window-config-9)
     ("C-c w w" . eyebrowse-last-window-config)
     ("C-c w k" . eyebrowse-close-window-config))
    :config
    ;; Resolve keybinding conflict with org
    (setq minor-mode-map-alist
          (assq-delete-all 'eyebrowse-mode minor-mode-map-alist))

    (setq eyebrowse-mode-line-style 'hide)
    (eyebrowse-mode))
#+END_SRC

** ibuffer - list-buffers replacement
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind
    ([remap list-buffers] . ibuffer))
#+END_SRC

** Buffer commands
Bury buffers, don't kill them. Computers have more than enough memory.

#+BEGIN_SRC emacs-lisp
  (defun koek-buff/bury-current (&optional arg)
    "Bury current.
  With `\\[universal-argument]' prefix argument ARG, kill current."
    (interactive "P")
    (if arg
        (kill-buffer)
      (bury-buffer)))

  (bind-key [remap kill-buffer] #'koek-buff/bury-current)
#+END_SRC

* Other

** Minibuffer
Enable minibuffer commands (e.g. [[*counsel - ivy powered commands][counsel]]) in minibuffer.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

** ivy - completing-read replacement
[[https://github.com/abo-abo/swiper][ivy (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :demand t
    :bind
    (("C-r" . ivy-resume)
     :map ivy-minibuffer-map
     ("C-c j" . ivy-avy))
    :config
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (counsel-unicode-char . ivy--regex-ignore-order)
            (t . ivy--regex-fuzzy)))
    (setq ivy-use-virtual-buffers t)
    (setq ivy-virtual-abbreviate 'full)
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-count-format "%d/%d ")
    (ivy-mode)
    :delight)
#+END_SRC

*** counsel - ivy powered commands
[[https://github.com/abo-abo/swiper][counsel (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (([remap find-file] . counsel-find-file)
     ([remap insert-char] . counsel-unicode-char)
     ([remap yank-pop] . counsel-yank-pop)
     ([remap execute-extended-command] . counsel-M-x)
     ([remap describe-variable] . counsel-describe-variable)
     ([remap describe-function] . counsel-describe-function)
     ([remap info-lookup-symbol] . counsel-info-lookup-symbol)))
#+END_SRC

*** flx - Score candidates
[[https://github.com/lewang/flx][flx (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package flx
    :ensure t)
#+END_SRC

** calendar - Calendar
#+BEGIN_SRC emacs-lisp
  (use-package calendar
    :config
    (setq calendar-week-start-day 1))     ; Monday
#+END_SRC

* Languages

** Emacs Lisp
#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :mode ((rx ".el" string-end) . emacs-lisp-mode)
    :delight (emacs-lisp-mode "El" :major))
#+END_SRC

** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :mode ((rx ".org" string-end) . org-mode)
    :bind
    (("C-c o c" . org-capture)
     ("C-c o a" . org-agenda)
     ("C-c o j" . counsel-org-goto-all)
     ("C-c o J" . org-clock-goto)
     ("C-c o o" . org-clock-out)
     ("C-c o x" . org-clock-cancel)
     ("C-c o l" . org-store-link)
     :map org-mode-map
     ("C-M-f" . org-forward-heading-same-level)
     ("C-M-b" . org-backward-heading-same-level)
     ("C-M-n" . org-next-visible-heading)
     ("C-M-p" . org-previous-visible-heading)
     ("C-M-u" . outline-up-heading)
     ("C-M-a" . org-previous-block)
     ("C-M-e" . org-next-block)
     ([remap org-set-tags-command] . counsel-org-tag)
     ("C-c o i" . org-clock-in)
     :map org-src-mode-map
     ("C-c o '" . org-edit-src-exit)
     ("C-c o k" . org-edit-src-abort))
    :preface
    ;; When editing code blocks, disable certain checkers
    (defconst koek-org/excluded-checkers
      '((emacs-lisp-mode . (emacs-lisp-checkdoc)))
      "Alist of excluded checker pairs.
  Pair is a cons. Its car is a major mode symbol, its cdr is a list
  of checker symbols.")

    (defun koek-org/disable-excluded-checkers ()
      "Disable excluded checkers for current."
      (dolist (checker (alist-get major-mode koek-org/excluded-checkers))
        (unless (memq checker flycheck-disabled-checkers)
          (push checker flycheck-disabled-checkers))))
    :config
    (defvar org-export-headline-levels)

    ;; Resolve keybinding conflict with cider
    (dolist (key '("C-c '" "C-c C-k"))
      (unbind-key key org-src-mode-map))

    (setq org-todo-keywords
          '((sequence "TODO(t)" "STALLED(s@/!)" "|" "DONE(d!)" "ABANDONED(a@)")))
    (setq org-adapt-indentation nil)
    (setq org-export-headline-levels 4)
    (add-hook 'org-src-mode-hook #'koek-org/disable-excluded-checkers))

  (use-package org-agenda
    :bind
    (:map org-agenda-mode-map
     ([remap org-agenda-set-tags] . counsel-org-tag-agenda)))
#+END_SRC

** Text
#+BEGIN_SRC emacs-lisp
  (use-package text-mode
    :mode (rx (or ".txt" "/README" "/LICENSE") string-end)
    :preface
    ;; See https://github.com/jwiegley/use-package/issues/267
    (provide 'text-mode)
    :delight (text-mode "Txt" :major))
#+END_SRC

** YASnippet
For the minor mode, see [[*yasnippet - Snippets][yasnippet - Snippets]].

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :mode ("/snippets/" . snippet-mode)
    :config
    (add-hook 'snippet-mode-hook #'koek-ws/disable-final-empty-line))
#+END_SRC

* Appearance
Maximize frames.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

Show file name in title bar.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '((:eval
           (let ((file-name (buffer-file-name)))
             (cond
              ((and (projectile-project-p) file-name)
               (format "~%s/%s"
                       (projectile-project-name)
                       (file-relative-name file-name (projectile-project-root))))
              (file-name
               (abbreviate-file-name file-name))
              (t
               "%b"))))
          " - Emacs"))
#+END_SRC

Disable menu bar, tool bar and scroll bars.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
#+END_SRC

Load [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow]] theme.

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t
    :preface
    (defun koek-thm/set-dark-wm-theme-variant (frame)
      "Set window manager theme variant of FRAME to dark."
      (call-process "xprop" nil nil nil
                    "-id" (frame-parameter frame 'outer-window-id)
                    "-f" "_GTK_THEME_VARIANT" "8u"
                    "-set" "_GTK_THEME_VARIANT" "dark"))

    (defun koek-thm/mix (color1 color2 &optional ratio)
      "Mix COLOR1 with COLOR2 according to RATIO.
  COLOR1 and COLOR2 are lists of RGB components, see
  `color-name-to-rgb'.  Optional RATIO is a float from zero to one
  and defaults to one half.  Zero means mix zero units of COLOR1
  with one unit of COLOR2, one means mix one unit of COLOR1 with
  zero units of COLOR2."
      (unless ratio
        (setq ratio 0.5))
      (let ((ratio´ (- 1 ratio)))
        (seq-mapn (lambda (component component´)
                    (+ (* component ratio) (* component´ ratio´)))
                  color1 color2)))
    :config
    (declare-function color-rgb-to-hex "color")
    (declare-function map-elt "map")

    ;; Set frame (i.e. window manager) theme
    (when (executable-find "xprop")
      (koek-thm/set-dark-wm-theme-variant (selected-frame))
      (add-hook 'after-make-frame-functions #'koek-thm/set-dark-wm-theme-variant))

    ;; Set window theme
    (load-theme 'sanityinc-tomorrow-eighties 'no-confirm)
    (let* ((theme (alist-get 'eighties color-theme-sanityinc-tomorrow-colors))
           (personal
            (mapcar
             (pcase-lambda (`(,name . ,rgb))
               (cons name (apply #'color-rgb-to-hex rgb)))
             (map-let                     ; How to use let-alist and backquote?
                 (current-line selection)
                 (mapcar (pcase-lambda (`(,name . ,hex))
                           (cons name (color-name-to-rgb hex)))
                         theme)
               `((alt . ,(koek-thm/mix current-line selection))))))
           (spec
            (map-let (alt selection orange) (append personal theme)
              `((mode-line-emphasis :foreground ,orange :slant unspecified)
                (whitespace-space   :foreground ,alt :background nil)
                (whitespace-hspace  :foreground ,alt :background nil)
                (whitespace-tab     :foreground ,alt :background nil)
                (whitespace-newline :foreground ,alt :background nil)
                (whitespace-trailing :foreground nil :background ,selection)
                (whitespace-empty    :foreground nil :background ,selection)
                (whitespace-line     :foreground nil :background ,selection)
                (eyebrowse-mode-line-active :foreground unspecified
                                            :weight unspecified
                                            :inherit mode-line-emphasis)))))
      ;; Adding attributes to a face before it's defined, fails. Add
      ;; attributes to user theme.
      (apply #'custom-set-faces
             (mapcar (pcase-lambda (`(,name . ,attribs))
                       `(,name ((t . ,attribs))))
                     spec))))
#+END_SRC

Set default font to [[https://adobe-fonts.github.io/source-code-pro/][Source Code Pro]].

#+BEGIN_SRC emacs-lisp
  (let ((family "Source Code Pro"))
    (when (x-list-fonts (format "*-%s-*" family))
      (set-face-attribute 'default nil :family family)))
#+END_SRC

Disable blink cursor mode, instead, enable highlight line mode.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (global-hl-line-mode)
#+END_SRC

Show:

- memory full
- function arguments
- variant name and diff status
- edit depth
- input name
- workspace names
- project name, buffer name and buffer state
- narrow, percentage buffer above first visible line, line number and
  column number
- clocked time
- version control name and branch name
- checker name, number of errors and number of warnings
- major name, process status and minor names

in mode line.

#+BEGIN_SRC emacs-lisp
  (defconst koek-ml/separator
    "   "
    "Mode line group separator.")

  (defconst koek-ml/ediff
    '((eldoc-mode-line-string
       nil)
      (:eval
       (let* ((diff-n (1+ ediff-current-difference))
              (n-diffs ediff-number-of-differences)
              (right (concat (cond
                              ((< diff-n 1)
                               (format "Start -/%d" n-diffs))
                              ((> diff-n n-diffs)
                               (format "End -/%d" n-diffs))
                              (t
                               (format "%d/%d" diff-n n-diffs)))
                             koek-ml/separator
                             "(Ediff) ")))
         `((,(max 0 (- (window-total-width) (string-width right)))
            (" "
             (eldoc-mode-line-string
              ("" eldoc-mode-line-string koek-ml/separator))
             (:propertize "%b" face mode-line-buffer-id)
             koek-ml/separator))
           ,right))))
    "List of mode line constructs for ediff control buffer.")

  (defvar-local koek-ml/variant-name
    nil
    "Name of variant.")

  (defvar-local koek-ml/diff-status
    nil
    "Status of current diff.")

  (defun koek-ml/variants ()
    "Return variants of current ediff session."
    (seq-filter (lambda (variant)
                  (bufferp (cdr variant)))
                `(("A" . ,ediff-buffer-A)
                  ("B" . ,ediff-buffer-B)
                  ("C" . ,ediff-buffer-C)
                  ("Ancestor" . ,ediff-ancestor-buffer))))

  (defun koek-ml/diff-status ()
    "Return status of current diff."
    (let ((status (nth 1 mode-line-format)))
      (when (symbolp status)
        (setq status (symbol-value status)))
      (unless (string= status "")
        (replace-regexp-in-string (rx (or (and string-start "[")
                                          (and "] " string-end)))
                                  "" status))))

  (define-advice ediff-refresh-mode-lines (:after () koek-ml/update-ediff)
    (setq mode-line-format koek-ml/ediff)
    (save-current-buffer
      (dolist (variant (koek-ml/variants))
        (set-buffer (cdr variant))
        (setq koek-ml/variant-name (car variant))
        (setq koek-ml/diff-status (koek-ml/diff-status))
        (ediff-strip-mode-line-format))))

  (defun koek-ml/cleanup-ediff ()
    "Cleanup ediff mode line variables."
    (save-current-buffer
      (dolist (variant (koek-ml/variants))
        (set-buffer (cdr variant))
        (kill-local-variable 'koek-ml/variant-name)
        (kill-local-variable 'koek-ml/diff-status))))

  (add-hook 'ediff-cleanup-hook #'koek-ml/cleanup-ediff)

  (declare-function eyebrowse--get "eyebrowse")

  (defun koek-ml/workspaces ()
    "Return workspaces of current frame."
    (eyebrowse--get 'window-configs))

  (defun koek-ml/current-workspace-id ()
    "Return workspace id of current frame."
    (eyebrowse--get 'current-slot))

  (defun koek-ml/workspace-id (workspace)
    "Return id of WORKSPACE."
    (car workspace))

  (defun koek-ml/workspace-name (workspace)
    "Return name of WORKSPACE."
    (let ((name (nth 2 workspace)))
      (unless (string= name "")
        name)))

  (defconst koek-ml/roman-numerals
    '((9 . "IX")
      (5 . "V")
      (4 . "IV")
      (1 . "I"))
    "Alist of sorted Arabic numeral to Roman numeral pairs.")

  (defun koek-ml/arabic-to-roman (n &optional roman-numerals)
    "Convert Arabic number N to Roman number.
  N is an integer greater than zero.  Optional ROMAN-NUMERALS is an
  alist of sorted Arabic numeral to Roman numeral pairs and
  defaults to `koek-ml/roman-numerals'."
    (unless roman-numerals
      (setq roman-numerals koek-ml/roman-numerals))
    (when (> n 0)
      (pcase-let ((`(,arabic . ,roman) (car roman-numerals)))
        (if (>= n arabic)
            (concat roman (koek-ml/arabic-to-roman (- n arabic) roman-numerals))
          (koek-ml/arabic-to-roman n (cdr roman-numerals))))))

  (defun koek-ml/workspace-label (workspace)
    "Return label of WORKSPACE.
  Label is made of a workspace id and name."
    (let ((id (or (koek-ml/arabic-to-roman (koek-ml/workspace-id workspace))
                  ;; Roman numeral zero doesn't exist. N stands for
                  ;; nulla, which means zero.
                  "N"))
          (name (koek-ml/workspace-name workspace)))
      (if name
          (format "%s:%s" id name)
        id)))

  (defconst koek-ml/checker-names
    '((emacs-lisp . "El")
      (emacs-lisp-checkdoc . "Checkdoc"))
    "Alist of checker symbol to checker name pairs.")

  (declare-function flycheck-get-checker-for-buffer "flycheck")

  (defun koek-ml/checker-name ()
    "Return name of current checker."
    (when-let (checker (flycheck-get-checker-for-buffer))
      (or (alist-get checker koek-ml/checker-names) "Checker")))

  (defconst koek-ml/left
    '(" "
      (memory-full
       ("Memory Full!" koek-ml/separator))
      (eldoc-mode-line-string
       ("" eldoc-mode-line-string koek-ml/separator))
      (koek-ml/variant-name
       ((:propertize koek-ml/variant-name face mode-line-emphasis)
        (koek-ml/diff-status
         (" " koek-ml/diff-status))
        koek-ml/separator))
      (:eval
       (let ((depth (- (recursion-depth) (minibuffer-depth))))
         (when (> depth 0)
           (format (concat "[%d]" koek-ml/separator) depth))))
      (current-input-method
       ("" current-input-method-title koek-ml/separator))
      (:eval
       (when eyebrowse-mode
         (let ((workspaces (koek-ml/workspaces))
               (current-id (koek-ml/current-workspace-id)))
           (when (or (> (length workspaces) 1) (not (= current-id 1)))
             (concat
              (mapconcat
               (lambda (workspace)
                 (let ((label (koek-ml/workspace-label workspace)))
                   (when (= (koek-ml/workspace-id workspace) current-id)
                     (setq label
                           (propertize label 'face 'eyebrowse-mode-line-active)))
                   label))
               workspaces " ")
              koek-ml/separator)))))
      ((:eval
        (when (projectile-project-p)
          (format "%s/" (projectile-project-name))))
       (:propertize "%b" face mode-line-buffer-id)
       " %*%+"))
    "List of mode line constructs shown left.")

  (defconst koek-ml/right
    '(((:eval
        (when (buffer-narrowed-p)
          (concat (propertize "Narrowed" 'face 'mode-line-emphasis) " ")))
       "%p"
       " %l,%c"
       koek-ml/separator)
      (:eval
       (when (org-clock-is-active)
         (concat (org-duration-from-minutes (org-clock-get-clocked-time))
                 koek-ml/separator)))
      (:eval
       (when vc-mode
         (let ((status (substring-no-properties vc-mode)))
           (string-match (rx (submatch-n 1 (one-or-more word))
                             (zero-or-one ":" (one-or-more word))
                             (any "-:@!?")
                             (submatch-n 2 (one-or-more word)))
                         status)
           (format (concat "%s %s" koek-ml/separator)
                   (match-string 1 status) (match-string 2 status)))))
      (:eval
       (when flycheck-mode
         (concat (pcase flycheck-last-status-change
                   (`running
                    (format "%s - -" (koek-ml/checker-name)))
                   (`finished
                    (let-alist (flycheck-count-errors flycheck-current-errors)
                      (format "%s %d %d"
                              (koek-ml/checker-name)
                              (or .error 0) (or .warning 0))))
                   (`,status
                    (capitalize
                     (replace-regexp-in-string "-" " " (symbol-name status)))))
                 koek-ml/separator)))
      ("(" mode-name mode-line-process minor-mode-alist ")")
      " ")
    "List of mode line constructs shown right.")

  (setq-default mode-line-format
                '(;; Prevent eldoc from modifying mode-line-format
                  (eldoc-mode-line-string
                   nil)
                  (:eval
                   (let* ((inhibit-mode-name-delight nil) ; Looked up dynamically
                          (right (format-mode-line koek-ml/right)))
                     `((,(max 0 (- (window-total-width) (string-width right)))
                        ("" koek-ml/left koek-ml/separator))
                       ;; Escape %'s
                       ,(replace-regexp-in-string "%" "%%" right))))))
#+END_SRC

* Footer
#+BEGIN_SRC emacs-lisp
  ;;; 50-general.el ends here
#+END_SRC

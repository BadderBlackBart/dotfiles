#+TITLE: General

* Header
Enable lexical binding. When visiting the tangled file, enable read
only mode.

#+BEGIN_SRC emacs-lisp
  ;;; 50-general.el --- General configuration -*- lexical-binding: t; buffer-read-only: t; -*-

  ;;; Commentary:

  ;; General configuration, part of Koekelas' Emacs configuration.

  ;;; Code:
#+END_SRC

Declare variables and functions setup by [[file:init.el][init.el]].

#+BEGIN_SRC emacs-lisp
  (defvar no-littering-etc-directory)
  (defvar no-littering-var-directory)
  (declare-function no-littering-expand-var-file-name "no-littering")
#+END_SRC

* Files

** projectile - Projects
[[https://github.com/bbatsov/projectile][projectile (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode)
    :delight)
#+END_SRC

** magit - Git
[[https://github.com/magit/magit][magit (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    ("C-c f g" . magit-status))
#+END_SRC

** ediff - Compare files
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :bind
    (("C-c f d" . ediff-files)
     ("C-c f b" . ediff-current-file))
    :preface
    (declare-function outline-show-all "outline")

    (defun koek-diff/unfold-outline ()
      "Unfold outline in outline and derived modes."
      (when (derived-mode-p 'outline-mode) ; org is derived from outline
        (outline-show-all)))
    :config
    (declare-function ediff-setup-windows-plain "ediff-wind")

    ;; Setup restore window layout on quit
    (let (last-layout)
      ;; Store window layout before it's modified. The control buffer
      ;; doesn't exist yet.
      (add-hook 'ediff-before-setup-hook
                (lambda ()
                  (setq last-layout (current-window-configuration))))
      ;; Store window layout in a local hook of the control buffer.
      ;; Current is the control buffer.
      (add-hook 'ediff-mode-hook
                (lambda ()
                  (let ((layout last-layout))
                    ;; Restore window layout on quit
                    (add-hook 'ediff-quit-hook
                              (lambda ()
                                (set-window-configuration layout))
                              'append 'local)))))

    (setq ediff-window-setup-function #'ediff-setup-windows-plain)
    (setq ediff-split-window-function #'split-window-horizontally)
    (add-hook 'ediff-prepare-buffer-hook #'koek-diff/unfold-outline))
#+END_SRC

** recentf - Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (mapc (apply-partially #'add-to-list 'recentf-exclude)
          (list no-littering-etc-directory no-littering-var-directory))
    (recentf-mode))
#+END_SRC

** Auto save files
Save auto-save files in ~/.emacs.d/var/auto-save/.

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+END_SRC

* Editor

** subword - Recognize words in camel case words
#+BEGIN_SRC emacs-lisp
  (use-package subword
    :init
    (add-hook 'prog-mode-hook #'subword-mode)
    :delight)
#+END_SRC

** Word motion commands
Complement word motion commands. Unlike =forward-to-word= and
=backward-to-word=, =koek-mtn/next-word= and =koek-mtn/previous-word=
recognize [[*subword - Recognize words in camel case words][subwords]].

#+BEGIN_SRC emacs-lisp
  (defun koek-mtn/next-word (&optional arg)
    "Move point to the beginning of next word, repeat ARG times.
  Optional ARG is an integer and defaults to one.  When ARG is
  negative, move point to the ending of previous word."
    (interactive "p")
    (unless arg
      (setq arg 1))
    (unless (= arg 0)
      (let ((step (/ arg (abs arg))))
        (when (or (and (> step 0) (looking-at (rx word)))
                  (and (< step 0)
                       (looking-back (rx word) (max (1- (point)) (point-min)))))
          (forward-word step))
        (forward-word (- arg step))
        (when (forward-word step)
          (backward-word step)))))

  (defun koek-mtn/previous-word (&optional arg)
    "Move point to the ending of previous word, repeat ARG times.
  Optional ARG is an integer and defaults to one.  When ARG is
  negative, move point to the beginning of next word."
    (interactive "p")
    (unless arg
      (setq arg 1))
    (koek-mtn/next-word (- arg)))

  (bind-key "M-n" #'koek-mtn/next-word)
  (bind-key "M-p" #'koek-mtn/previous-word)
#+END_SRC

** auto-fill-mode - Break long sentences
#+BEGIN_SRC emacs-lisp
  (defconst koek-af/exclude-modes
    '(snippet-mode)
    "List of major mode symbols, see `koek-af/maybe-enable'.")

  (defun koek-af/maybe-enable ()
    "Enable `auto-fill-mode' conditionally.
  Unless current major mode is a member of `koek-af/exclude-modes',
  enable `auto-fill-mode'."
    (unless (memq major-mode koek-af/exclude-modes)
      (auto-fill-mode)))

  (add-hook 'text-mode-hook #'koek-af/maybe-enable)
  (delight 'auto-fill-function nil 'emacs)
#+END_SRC

** smartparens - Pairs & expressions
[[https://github.com/Fuco1/smartparens][smartparens (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :bind
    (:map smartparens-mode-map
     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)
     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)
     ("C-M-d" . sp-down-sexp)
     ("C-M-u" . sp-up-sexp)
     ("C-S-d" . sp-backward-down-sexp)
     ("C-S-u" . sp-backward-up-sexp)
     ("C-M-<right>" . sp-forward-slurp-sexp)
     ("C-M-<left>"  . sp-forward-barf-sexp)
     ("C-S-<left>"  . sp-backward-slurp-sexp)
     ("C-S-<right>" . sp-backward-barf-sexp)
     ("C-M-<down>"  . sp-unwrap-sexp)
     ("C-M-t" . sp-transpose-sexp)
     ("C-M-w" . sp-copy-sexp)
     ("C-M-k" . sp-kill-sexp))
    :init
    (bind-key "C-M-{" #'beginning-of-defun)
    (bind-key "C-M-}" #'end-of-defun)
    (bind-key "C-S-w" #'append-next-kill)
    (add-hook 'prog-mode-hook #'smartparens-mode)
    :config
    (require 'smartparens-config)
    (add-hook 'smartparens-mode-hook #'show-smartparens-mode)
    :delight)
#+END_SRC

** Whitespace
Indent with spaces, not tabs.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

End sentences with a single space, not a double space.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

End files with an empty line.

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)

  (defun koek-ws/disable-final-empty-line ()
    "Disable final empty line for current."
    (setq-local require-final-newline nil))
#+END_SRC

** whitespace - Clean & visualize whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :init
    (add-hook 'prog-mode-hook #'whitespace-mode)
    :config
    (setq whitespace-style
          '(space-mark tab-mark newline-mark
            face spaces tabs newline trailing empty lines-tail))
    (setq whitespace-display-mappings
          '((space-mark   ?\    [?·])
            (space-mark   ?\xA0 [?¤])
            (tab-mark     ?\t   [?⇥ ?\t])
            (newline-mark ?\n   [?↵ ?\n])))
    (add-hook 'before-save-hook #'whitespace-cleanup)
    :delight)
#+END_SRC

** yasnippet - Snippets
[[https://github.com/joaotavora/yasnippet][yasnippet (GitHub)]]

For the major mode, see [[*YASnippet][YASnippet]].

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :preface
    (declare-function yas-reload-all "yasnippet")
    :init
    (dolist (hook '(text-mode-hook prog-mode-hook))
      (add-hook hook #'yas-minor-mode))
    :config
    ;; Load own snippets
    (setq yas-snippet-dirs (delq 'yas-installed-snippets-dir yas-snippet-dirs))
    (yas-reload-all)

    ;; Set new snippet file snippet
    (with-temp-buffer
      (insert-file-contents
       (expand-file-name "yasnippet/snippets/snippet-mode/new"
                         no-littering-etc-directory))
      (setq yas-new-snippet-default
            (buffer-substring (re-search-forward (rx line-start "# --\n"))
                              (point-max))))
    :delight yas-minor-mode)
#+END_SRC

** ispell - Spell checker
#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :config
    (setq ispell-program-name (executable-find "hunspell"))
    (let ((dictionary-name "en_US"))
      ;; Hunspell on Windows requires DICTIONARY environment variable to
      ;; be set
      (when (eq system-type 'windows-nt)
        (setenv "DICTIONARY" dictionary-name))
      (setq ispell-dictionary dictionary-name)))
#+END_SRC

** flycheck - Show syntax & style errors
[[https://github.com/flycheck/flycheck][flycheck (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'flycheck-mode)
    :delight)
#+END_SRC

* Windows & buffers

** eyebrowse - Workspaces
[[https://github.com/wasamasa/eyebrowse][eyebrowse (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :ensure t
    :bind
    (("C-c w 0" . eyebrowse-switch-to-window-config-0)
     ("C-c w 1" . eyebrowse-switch-to-window-config-1)
     ("C-c w 2" . eyebrowse-switch-to-window-config-2)
     ("C-c w 3" . eyebrowse-switch-to-window-config-3)
     ("C-c w 4" . eyebrowse-switch-to-window-config-4)
     ("C-c w 5" . eyebrowse-switch-to-window-config-5)
     ("C-c w 6" . eyebrowse-switch-to-window-config-6)
     ("C-c w 7" . eyebrowse-switch-to-window-config-7)
     ("C-c w 8" . eyebrowse-switch-to-window-config-8)
     ("C-c w 9" . eyebrowse-switch-to-window-config-9)
     ("C-c w w" . eyebrowse-last-window-config)
     ("C-c w k" . eyebrowse-close-window-config))
    :config
    (setq eyebrowse-mode-line-style 'hide)
    (eyebrowse-mode))
#+END_SRC

** ibuffer - list-buffers replacement
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind
    ([remap list-buffers] . ibuffer))
#+END_SRC

** Buffer commands
Bury buffers, don't kill them. Computers have more than enough memory.

#+BEGIN_SRC emacs-lisp
  (defun koek-buff/bury-current (&optional arg)
    "Bury current.
  With `\\[universal-argument]' prefix argument ARG, kill current."
    (interactive "P")
    (if arg
        (kill-buffer)
      (bury-buffer)))

  (bind-key [remap kill-buffer] #'koek-buff/bury-current)
#+END_SRC

* Languages

** Emacs Lisp
#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :mode ((rx ".el" string-end) . emacs-lisp-mode)
    :delight (emacs-lisp-mode "El" :major))
#+END_SRC

** Text
#+BEGIN_SRC emacs-lisp
  (use-package text-mode
    :mode (rx (or ".txt" "/README" "/LICENSE") string-end)
    :preface
    ;; See https://github.com/jwiegley/use-package/issues/267
    (provide 'text-mode)
    :delight (text-mode "Txt" :major))
#+END_SRC

** YASnippet
For the minor mode, see [[*yasnippet - Snippets][yasnippet - Snippets]].

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :mode ("/snippets/" . snippet-mode)
    :config
    (add-hook 'snippet-mode-hook #'koek-ws/disable-final-empty-line))
#+END_SRC

* Appearance
Maximize frames.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

Show file name in title bar.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '((:eval
           (let ((file-name (buffer-file-name)))
             (cond
              ((and (projectile-project-p) file-name)
               (format "~%s/%s"
                       (projectile-project-name)
                       (file-relative-name file-name (projectile-project-root))))
              (file-name
               (abbreviate-file-name file-name))
              (t
               "%b"))))
          " - Emacs"))
#+END_SRC

Disable menu bar, tool bar and scroll bars.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
#+END_SRC

Load [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow]] theme.

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t
    :preface
    (defun koek-thm/mix (color1 color2 &optional ratio)
      "Mix COLOR1 with COLOR2 according to RATIO.
  COLOR1 and COLOR2 are lists of RGB components, see
  `color-name-to-rgb'.  Optional RATIO is a float from zero to one
  and defaults to one half.  Zero means mix zero units of COLOR1
  with one unit of COLOR2, one means mix one unit of COLOR1 with
  zero units of COLOR2."
      (unless ratio
        (setq ratio 0.5))
      (let ((ratio´ (- 1 ratio)))
        (seq-mapn (lambda (component component´)
                    (+ (* component ratio) (* component´ ratio´)))
                  color1 color2)))
    :config
    (declare-function color-rgb-to-hex "color")
    (declare-function map-elt "map")

    (load-theme 'sanityinc-tomorrow-eighties 'no-confirm)
    (let* ((theme (alist-get 'eighties color-theme-sanityinc-tomorrow-colors))
           (personal
            (mapcar
             (pcase-lambda (`(,name . ,rgb))
               (cons name (apply #'color-rgb-to-hex rgb)))
             (map-let                     ; How to use let-alist and backquote?
                 (current-line selection)
                 (mapcar (pcase-lambda (`(,name . ,hex))
                           (cons name (color-name-to-rgb hex)))
                         theme)
               `((alt . ,(koek-thm/mix current-line selection))))))
           (spec
            (map-let (alt selection) (append personal theme)
              `((whitespace-space   :foreground ,alt :background nil)
                (whitespace-hspace  :foreground ,alt :background nil)
                (whitespace-tab     :foreground ,alt :background nil)
                (whitespace-newline :foreground ,alt :background nil)
                (whitespace-trailing :foreground nil :background ,selection)
                (whitespace-empty    :foreground nil :background ,selection)
                (whitespace-line     :foreground nil :background ,selection)
                (eyebrowse-mode-line-active :weight normal)))))
      ;; Adding attributes to a face before the face is defined, fails.
      ;; Add attributes to the user theme.
      (apply #'custom-set-faces
             (mapcar (pcase-lambda (`(,name . ,attribs))
                       `(,name ((t . ,attribs))))
                     spec))))
#+END_SRC

Set default font to [[https://adobe-fonts.github.io/source-code-pro/][Source Code Pro]].

#+BEGIN_SRC emacs-lisp
  (let ((family "Source Code Pro"))
    (when (x-list-fonts (format "*-%s-*" family))
      (set-face-attribute 'default nil :family family)))
#+END_SRC

Disable blink cursor mode, instead, enable highlight line mode.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (global-hl-line-mode)
#+END_SRC

Show:

- memory full
- function arguments
- edit depth
- input name
- workspace names
- project name, buffer name and buffer state
- narrow, percentage buffer above first visible line, line number and
  column number
- version control name and branch name
- checker name, number of errors and number of warnings
- major name and minor names

in mode line.

#+BEGIN_SRC emacs-lisp
  (declare-function eyebrowse--get "eyebrowse")

  (defun koek-ml/workspaces ()
    "Return workspaces of current frame."
    (eyebrowse--get 'window-configs))

  (defun koek-ml/current-workspace-id ()
    "Return workspace id of current frame."
    (eyebrowse--get 'current-slot))

  (defun koek-ml/workspace-id (workspace)
    "Return id of WORKSPACE."
    (car workspace))

  (defun koek-ml/workspace-name (workspace)
    "Return name of WORKSPACE."
    (let ((name (nth 2 workspace)))
      (unless (equal name "")
        name)))

  (defconst koek-ml/roman-numerals
    '((9 . "IX")
      (5 . "V")
      (4 . "IV")
      (1 . "I"))
    "Alist of sorted Arabic numeral to Roman numeral pairs.")

  (defun koek-ml/arabic-to-roman (n &optional roman-numerals)
    "Convert Arabic number N to Roman number.
  N is an integer greater than zero.  Optional ROMAN-NUMERALS is an
  alist of sorted Arabic numeral to Roman numeral pairs and
  defaults to `koek-ml/roman-numerals'."
    (unless roman-numerals
      (setq roman-numerals koek-ml/roman-numerals))
    (when (> n 0)
      (pcase-let ((`(,arabic . ,roman) (car roman-numerals)))
        (if (>= n arabic)
            (concat roman (koek-ml/arabic-to-roman (- n arabic) roman-numerals))
          (koek-ml/arabic-to-roman n (cdr roman-numerals))))))

  (defun koek-ml/workspace-label (workspace)
    "Return label of WORKSPACE.
  A label is made of a workspace id and name."
    (let ((id (or (koek-ml/arabic-to-roman (koek-ml/workspace-id workspace))
                  ;; A Roman numeral for zero doesn't exist. N stands
                  ;; for nulla, which means zero.
                  "N"))
          (name (koek-ml/workspace-name workspace)))
      (if name
          (format "%s:%s" id name)
        id)))

  (defconst koek-ml/checker-names
    '((emacs-lisp . "El")
      (emacs-lisp-checkdoc . "Checkdoc"))
    "Alist of checker symbol to checker name pairs.")

  (declare-function flycheck-get-checker-for-buffer "flycheck")

  (defun koek-ml/current-checker-name ()
    "Return checker name of current."
    (when-let (checker (flycheck-get-checker-for-buffer))
      (or (alist-get checker koek-ml/checker-names) "Checker")))

  (defconst koek-ml/separator
    "   "
    "Mode line group separator.")

  (defconst koek-ml/left
    '(" "
      (memory-full
       ("Memory Full!" koek-ml/separator))
      (eldoc-mode-line-string
       ("" eldoc-mode-line-string koek-ml/separator))
      (:eval
       (let ((depth (- (recursion-depth) (minibuffer-depth))))
         (when (> depth 0)
           (format "[%d]%s" depth koek-ml/separator))))
      (current-input-method
       ("" current-input-method-title koek-ml/separator))
      (:eval
       (when eyebrowse-mode
         (let ((workspaces (koek-ml/workspaces)))
           (when (> (length workspaces) 1)
             (let ((current-id (koek-ml/current-workspace-id)))
               (format
                "[%s]%s"
                (mapconcat
                 (lambda (workspace)
                   (let ((label (koek-ml/workspace-label workspace)))
                     (when (equal (koek-ml/workspace-id workspace) current-id)
                       (setq label
                             (propertize label
                                         'face 'eyebrowse-mode-line-active)))
                     label))
                 workspaces " ")
                koek-ml/separator))))))
      ((:eval
        (when (projectile-project-p)
          (format "%s/" (projectile-project-name))))
       (:propertize "%b" face mode-line-buffer-id)
       " %*%+"))
    "List of mode line constructs shown left.")

  (defconst koek-ml/right
    '(((:eval
        (when (buffer-narrowed-p)
          "Narrowed "))
       "%p"
       " %l,%c"
       koek-ml/separator)
      (:eval
       (when vc-mode
         (let ((status (substring-no-properties vc-mode)))
           (string-match (rx (submatch-n 1 (one-or-more word))
                             (zero-or-one ":" (one-or-more word))
                             (any "-:@!?")
                             (submatch-n 2 (one-or-more word)))
                         status)
           (format "%s %s%s"
                   (match-string 1 status) (match-string 2 status)
                   koek-ml/separator))))
      (:eval
       (when flycheck-mode
         (concat (pcase flycheck-last-status-change
                   (`running
                    (format "%s - -" (koek-ml/current-checker-name)))
                   (`finished
                    (let-alist (flycheck-count-errors flycheck-current-errors)
                      (format "%s %d %d"
                              (koek-ml/current-checker-name)
                              (or .error 0) (or .warning 0))))
                   (`,status
                    (capitalize
                     (replace-regexp-in-string "-" " " (symbol-name status)))))
                 koek-ml/separator)))
      ("(" mode-name minor-mode-alist ")")
      " ")
    "List of mode line constructs shown right.")

  (setq-default mode-line-format
                '(;; Prevent eldoc from modifying mode-line-format
                  (eldoc-mode-line-string
                   nil)
                  (:eval
                   (let* ((inhibit-mode-name-delight nil) ; Looked up dynamically
                          (right (format-mode-line koek-ml/right)))
                     `((;; FIXME: When a package (e.g. ediff) wraps
                        ;; mode-line-format, pad width is wrong
                        ,(max 0 (- (window-total-width) (string-width right)))
                        ("" koek-ml/left koek-ml/separator))
                       ;; Escape %'s
                       ,(replace-regexp-in-string "%" "%%" right))))))
#+END_SRC

Disable startup screen.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

* Footer
#+BEGIN_SRC emacs-lisp
  ;;; 50-general.el ends here
#+END_SRC

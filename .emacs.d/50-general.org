#+TITLE: General
#+PROPERTY: header-args:emacs-lisp :lexical yes

* Header
Enable lexical binding. When visiting the tangled file, enable read
only mode.

#+BEGIN_SRC emacs-lisp
  ;;; 50-general.el --- General configuration -*- lexical-binding: t; buffer-read-only: t; -*-

  ;;; Commentary:

  ;; General configuration, part of Koekelas' Emacs configuration.

  ;;; Code:
#+END_SRC

Require libraries.

#+BEGIN_SRC emacs-lisp
  (require 'map)
  (require 'subr-x)
#+END_SRC

Declare variables and functions setup by [[file:init.el][init.el]].

#+BEGIN_SRC emacs-lisp
  (defvar no-littering-etc-directory)
  (defvar no-littering-var-directory)
  (declare-function koek-pkg/ensure "init")
  (declare-function no-littering-expand-var-file-name "no-littering")
#+END_SRC

* Files

** dired - File manager
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :bind
    ("C-c f f" . dired)
    :config
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq dired-dwim-target t)
    ;; For switches supported by ls-lisp, see
    ;; `ls-lisp--insert-directory'
    (setq dired-listing-switches "-lah"))
#+END_SRC

** Trash
Move deleted files to trash.

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

** projectile - Projects
[[https://github.com/bbatsov/projectile][projectile (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-c p") projectile-command-map)

    (setq projectile-completion-system 'ivy)
    (projectile-mode)
    :delight)
#+END_SRC

** magit - Git
[[https://github.com/magit/magit][magit (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package magit-status
    :ensure magit
    :bind
    ("C-c f g" . magit-status))

  (use-package git-commit
    :defer t
    :preface
    (defun koek-git/check-spelling (force)
      "Check spelling of commit message.
  When FORCE is truthy, continue commit unconditionally."
      (let* ((ispell-skip-region-alist    ; Dynamic variable
              (cons `(,(rx line-start "#") forward-line) ; Single line comment
                    ispell-skip-region-alist))
             (tick (buffer-chars-modified-tick))
             (result (ispell-buffer)))
        (cond
         (force t)
         (result ; When spell check was completed, result is truthy
          ;; When nothing was corrected, character tick counter didn't
          ;; change
          (or (= (buffer-chars-modified-tick) tick)
              (y-or-n-p "Spelling checked.  Commit? "))))))
    :config
    (add-hook 'git-commit-finish-query-functions #'koek-git/check-spelling))
#+END_SRC

** ediff - Diff viewer
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :bind
    (("C-c f d" . ediff-files)
     ("C-c f b" . ediff-current-file)))

  (use-package ediff-init
    :defer t
    :preface
    (declare-function outline-show-all "outline")

    (defun koek-diff/unfold-outline ()
      "Unfold outline in outline and derived modes."
      (when (derived-mode-p 'outline-mode) ; org is derived from outline
        (outline-show-all)))
    :config
    ;; Restore window layout on quit
    (let (last-layout)
      ;; Store window layout before it's modified. Control buffer
      ;; doesn't exist yet.
      (add-hook 'ediff-before-setup-hook
                (lambda ()
                  (setq last-layout (current-window-configuration))))
      ;; Store window layout in a local hook of control buffer. Current
      ;; is control buffer.
      (add-hook 'ediff-mode-hook
                (lambda ()
                  (let ((layout last-layout))
                    ;; Restore window layout
                    (add-hook 'ediff-quit-hook
                              (lambda ()
                                (set-window-configuration layout))
                              'append 'local)))))

    (add-hook 'ediff-prepare-buffer-hook #'koek-diff/unfold-outline))

  (use-package ediff-wind
    :defer t
    :config
    (declare-function ediff-setup-windows-plain "ediff-wind")

    (setq ediff-grab-mouse nil)
    (setq ediff-window-setup-function #'ediff-setup-windows-plain)
    (setq ediff-split-window-function #'split-window-right))
#+END_SRC

** autorevert - Revert file on external change
#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :config
    (global-auto-revert-mode)
    :delight auto-revert-mode)
#+END_SRC

** recentf - Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (mapc (apply-partially #'add-to-list 'recentf-exclude)
          (list "/share/emacs/"
                ;; Elements are regexps, ~/ and /home/user/ differ
                (expand-file-name (locate-user-emacs-file "elpa/"))
                no-littering-etc-directory
                no-littering-var-directory))
    (recentf-mode))
#+END_SRC

** saveplace - Restore point on revisit
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :config
    (save-place-mode))
#+END_SRC

** Auto save files
Save auto-save files in =~/.emacs.d/var/auto-save/=.

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+END_SRC

* Editor

** swiper - isearch replacement
[[https://github.com/abo-abo/swiper][swiper (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind
    (;; Why does [remap isearch-forward] prevent pdf-view-mode from
     ;; rebinding C-s?
     ("C-s" . swiper-isearch)
     :map swiper-map
     ("C-c j" . swiper-avy)))
#+END_SRC

** avy - Jump to visible position
[[https://github.com/abo-abo/avy][avy (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    (("C-c j j" . avy-goto-char-timer)
     ([remap goto-line] . avy-goto-line))
    :config
    (setq avy-all-windows nil)
    (setq avy-all-windows-alt 'all-frames)
    (setq avy-keys '(?q ?s ?d ?f ?j ?k ?l ?m))
    (setq avy-dispatch-alist nil))
#+END_SRC

*** link-hint - Jump to visible link
[[https://github.com/noctuid/link-hint.el][link-hint (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :ensure t
    :bind
    ("C-c j l" . link-hint-open-link))
#+END_SRC

*** Issues

**** Avy and Prettify Symbols conflict
See [[https://github.com/abo-abo/avy/issues/103][Issue 103 (GitHub)]].

** Jump to recent mark positions
When popping mark, skip consecutive identical marks.

#+BEGIN_SRC emacs-lisp
  (define-advice pop-to-mark-command (:around (f) koek-mark/ensure-move)
    (let ((start (point))
          (n (length mark-ring)))
      ;; Move point to current mark
      (funcall f)
      ;; Move point to previous marks in mark ring
      (while (and (= (point) start) (> n 0))
        (funcall f)
        (setq n (1- n)))))
#+END_SRC

** subword - Recognize words in camel case words
#+BEGIN_SRC emacs-lisp
  (use-package subword
    :hook
    ((prog-mode conf-mode eshell-mode comint-mode cider-repl-mode
      indium-repl-mode)
     . subword-mode)
    :delight)
#+END_SRC

** Word motion commands
Complement word motion commands. Unlike ~forward-to-word~ and
~backward-to-word~, ~koek-mtn/next-word~ and ~koek-mtn/previous-word~
recognize [[*subword - Recognize words in camel case words][subwords]].

#+BEGIN_SRC emacs-lisp
  (defun koek-mtn/next-word (&optional arg)
    "Move point to beginning of next word, repeat ARG times.
  Optional ARG is an integer and defaults to one.  When ARG is
  negative, move point to ending of previous word."
    (interactive "p")
    (unless arg
      (setq arg 1))
    (unless (= arg 0)
      (let ((step (/ arg (abs arg))))
        (when (or (and (> step 0) (looking-at (rx word)))
                  (and (< step 0)
                       (looking-back (rx word) (max (1- (point)) (point-min)))))
          (forward-word step))
        (forward-word (- arg step))
        (when (forward-word step)
          (backward-word step)))))

  (defun koek-mtn/previous-word (&optional arg)
    "Move point to ending of previous word, repeat ARG times.
  Optional ARG is an integer and defaults to one.  When ARG is
  negative, move point to beginning of next word."
    (interactive "p")
    (unless arg
      (setq arg 1))
    (koek-mtn/next-word (- arg)))

  (bind-keys
   ("M-n" . koek-mtn/next-word)
   ("M-p" . koek-mtn/previous-word))
#+END_SRC

** auto-fill - Break long sentences
#+BEGIN_SRC emacs-lisp
  (defconst koek-af/excluded-modes '(snippet-mode)
    "List of major mode symbols, see `koek-af/maybe-enable'.")

  (defun koek-af/maybe-enable ()
    "Enable `auto-fill-mode' conditionally.
  Unless current major mode is member of `koek-af/excluded-modes',
  enable `auto-fill-mode'."
    (unless (memq major-mode koek-af/excluded-modes)
      (auto-fill-mode)))

  (add-hook 'text-mode-hook #'koek-af/maybe-enable)
  (delight 'auto-fill-function nil 'emacs)
#+END_SRC

** smartparens - Pairs & symbolic expressions
[[https://github.com/Fuco1/smartparens][smartparens (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :bind
    (:map smartparens-mode-map
     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)
     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)
     ("C-M-d" . sp-down-sexp)
     ("C-M-u" . sp-up-sexp)
     ("C-S-d" . sp-backward-down-sexp)
     ("C-S-u" . sp-backward-up-sexp)
     ("C-M-t" . sp-transpose-sexp)
     ("C-M-(" . sp-split-sexp)
     ("C-M-<right>" . sp-forward-slurp-sexp)
     ("C-M-<left>"  . sp-forward-barf-sexp)
     ("C-S-<left>"  . sp-backward-slurp-sexp)
     ("C-S-<right>" . sp-backward-barf-sexp)
     ("C-M-<down>"  . sp-unwrap-sexp)
     ("C-M-w" . sp-copy-sexp)
     ("C-M-k" . sp-kill-sexp))
    :hook
    (((prog-mode conf-mode eshell-mode comint-mode cider-repl-mode
       indium-repl-mode)
      . smartparens-mode)
     (smartparens-mode . show-smartparens-mode))
    :preface
    (declare-function sp--get-context "smartparens")
    (declare-function sp-get-pair "smartparens")
    (declare-function sp-local-pair "smartparens")

    (defun koek-sp/separate-sexp (open-delimiter action _context)
      "Separate just inserted sexp from previous and/or next sexp.
  OPEN-DELIMITER is a string, the delimiter inserted.  ACTION is a
  symbol, the action performed, see `sp-pair'.  _CONTEXT is
  ignored."
      (when (and (eq action 'insert)
                 ;; Outer context, _context is inner context
                 (save-excursion
                   (search-backward open-delimiter)
                   (eq (sp--get-context) 'code)))
        (save-excursion
          (search-backward open-delimiter)
          (unless (looking-back (rx (or (any "#'`,~@([{" blank) line-start))
                                (max (1- (point)) (point-min)))
            (insert " "))
          (search-forward open-delimiter)
          (search-forward (sp-get-pair open-delimiter :close))
          (unless (looking-at (rx (or (any ")]}" blank) line-end)))
            (insert " ")))))

    (defun koek-sp/setup-separate-sexp-handler (mode &rest open-delimiters)
      "Setup separate-sexp handler in MODE for OPEN-DELIMITERS.
  MODE is a major mode symbol.  OPEN-DELIMITERS are one or more
  strings."
      (dolist (open-delimiter open-delimiters)
        (sp-local-pair mode open-delimiter nil
                       :post-handlers '(:add koek-sp/separate-sexp))))

    (defun koek-sp/format-c-block (open-delimiter action _context)
      "Format just inserted multiple line C block.
  OPEN-DELIMITER is a string, the delimiter inserted.  ACTION is a
  symbol, the action performed, see `sp-pair'.  _CONTEXT is
  ignored."
      (when (and (eq action 'insert)
                 (save-excursion
                   (search-backward open-delimiter)
                   (eq (sp--get-context) 'code)))
        (save-excursion
          (insert "\n")
          (indent-according-to-mode))
        (indent-according-to-mode)))

    (defun
        koek-sp/setup-format-c-block-on-return-handler
        (mode &rest open-delimiters)
      "Setup format-c-block handler in MODE for OPEN-DELIMITERS.
  MODE is a major mode symbol.  OPEN-DELIMITERS are one or more
  strings."
      (dolist (open-delimiter open-delimiters)
        (sp-local-pair mode open-delimiter nil
                       ;; For event names, see `single-key-description'
                       :post-handlers '(:add (koek-sp/format-c-block "RET")))))
    :init
    (bind-keys
     ("C-M-{" . beginning-of-defun)
     ("C-M-}" . end-of-defun)
     ("C-S-w" . append-next-kill))
    :config
    (require 'smartparens-config)

    (setq sp-navigate-interactive-always-progress-point t)
    (setq sp-navigate-reindent-after-up ())
    (setq sp-highlight-pair-overlay nil)
    (koek-sp/setup-separate-sexp-handler 'clojure-mode "(" "[" "{" "\"")
    (koek-sp/setup-separate-sexp-handler 'lisp-mode "(" "\"")
    (koek-sp/setup-separate-sexp-handler 'emacs-lisp-mode "(" "[" "\"")
    (koek-sp/setup-separate-sexp-handler 'scheme-mode "(" "\"")
    (koek-sp/setup-format-c-block-on-return-handler 'c-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'c++-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'css-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'java-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'js2-mode "{" "[")
    (koek-sp/setup-format-c-block-on-return-handler 'json-mode "{" "[")
    (koek-sp/setup-format-c-block-on-return-handler 'scad-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'python-mode "{" "[" "(")
    :delight)
#+END_SRC

** paren-face - Dim brackets
[[https://github.com/tarsius/paren-face][paren-face (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package paren-face
    :ensure t
    :config
    (global-paren-face-mode))
#+END_SRC

** expand-region - Mark increasingly larger unit
[[https://github.com/magnars/expand-region.el][expand-region (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind
    ("C-S-SPC" . er/expand-region)
    :config
    (setq expand-region-smart-cursor t))
#+END_SRC

** prettify-symbols - Show composed symbols
#+BEGIN_SRC emacs-lisp
  (defun koek-ps/make-baseline-right-left-spec (&rest chars)
    "Return composition specification for CHARS.
  CHARS are two or more characters.  Baseline right of previous
  character is composed with baseline left of next character."
    (seq-reduce (lambda (spec char)
                  (append spec (list '(Br . Bl) char)))
                (cdr chars) (list (car chars))))

  (defconst koek-ps/comp-specs
    (let ((safe '(("function" . ?ƒ)
                  ("lambda"   . ?λ)))
          (pragmata                       ; PragmataPro 0.828
           (when (member "PragmataPro Mono" (font-family-list))
             (mapcar
              (pcase-lambda (`(,symbol . ,char))
                (cons symbol
                      ;; Widen char to symbol characters
                      (apply #'koek-ps/make-baseline-right-left-spec
                             (append (make-list (1- (length symbol)) ?\s)
                                     (list char)))))
              '(("[ERROR]"   . ?\uE2C0) ("[DEBUG]"    . ?\uE2C1)
                ("[INFO]"    . ?\uE2C2) ("[WARN]"     . ?\uE2C3)
                ("[WARNING]" . ?\uE2C4) ("[ERR]"      . ?\uE2C5)
                ("[FATAL]"   . ?\uE2C6) ("[TRACE]"    . ?\uE2C7)
                ("[FIXME]"   . ?\uE2C8) ("[TODO]"     . ?\uE2C9)
                ("[BUG]"     . ?\uE2CA) ("[NOTE]"     . ?\uE2CB)
                ("[HACK]"    . ?\uE2CC) ("[MARK]"     . ?\uE2CD)
                ("[FAIL]"    . ?\uE2CE) ("// ERROR"   . ?\uE2E0)
                ("// DEBUG"  . ?\uE2E1) ("// INFO"    . ?\uE2E2)
                ("// WARN"   . ?\uE2E3) ("// WARNING" . ?\uE2E4)
                ("// ERR"    . ?\uE2E5) ("// FATAL"   . ?\uE2E6)
                ("// TRACE"  . ?\uE2E7) ("// FIXME"   . ?\uE2E8)
                ("// TODO"   . ?\uE2E9) ("// BUG"     . ?\uE2EA)
                ("// NOTE"   . ?\uE2EB) ("// HACK"    . ?\uE2EC)
                ("// MARK"   . ?\uE2ED) ("// FAIL"    . ?\uE2EE)
                ("# ERROR"   . ?\uE2F0) ("# DEBUG"    . ?\uE2F1)
                ("# INFO"    . ?\uE2F2) ("# WARN"     . ?\uE2F3)
                ("# WARNING" . ?\uE2F4) ("# ERR"      . ?\uE2F5)
                ("# FATAL"   . ?\uE2F6) ("# TRACE"    . ?\uE2F7)
                ("# FIXME"   . ?\uE2F8) ("# TODO"     . ?\uE2F9)
                ("# BUG"     . ?\uE2FA) ("# NOTE"     . ?\uE2FB)
                ("# HACK"    . ?\uE2FC) ("# MARK"     . ?\uE2FD)
                ("# FAIL"    . ?\uE2FE)
                ;; !
                ("!!"  . ?\uE900) ("!="  . ?\uE901) ("!==" . ?\uE902)
                ("!!!" . ?\uE903) ("!≡"  . ?\uE904) ("!≡≡" . ?\uE905)
                ("!>"  . ?\uE906) ("!=<" . ?\uE907)
                ;; #
                ("#("  . ?\uE920) ("#_" . ?\uE921) ("#{" . ?\uE922)
                ("#?"  . ?\uE923) ("#>" . ?\uE924) ("##" . ?\uE925)
                ("#_(" . ?\uE926)
                ;; %
                ("%="  . ?\uE930) ("%>" . ?\uE931) ("%>%" . ?\uE932)
                ("%<%" . ?\uE933)
                ;; &
                ("&%" . ?\uE940) ("&&"  . ?\uE941) ("&*" . ?\uE942)
                ("&+" . ?\uE943) ("&-"  . ?\uE944) ("&/" . ?\uE945)
                ("&=" . ?\uE946) ("&&&" . ?\uE947) ("&>" . ?\uE948)
                ;; $
                ("$>" . ?\uE955)
                ;; *
                ("***" . ?\uE960) ("*=" . ?\uE961) ("*/" . ?\uE962)
                ("*>"  . ?\uE963)
                ;; +
                ("++" . ?\uE970) ("+++" . ?\uE971) ("+=" . ?\uE972)
                ("+>" . ?\uE973) ("++=" . ?\uE974)
                ;; -
                ("--"   . ?\uE980) ("-<"  . ?\uE981) ("-<<" . ?\uE982)
                ("-="   . ?\uE983) ("->"  . ?\uE984) ("->>" . ?\uE985)
                ("---"  . ?\uE986) ("-->" . ?\uE987) ("-+-" . ?\uE988)
                ("-\\/" . ?\uE989) ("-|>" . ?\uE98A) ("-<|" . ?\uE98B)
                ("->-"  . ?\uE98C) ("-<-" . ?\uE98D)
                ;; .
                (".." . ?\uE990) ("..." . ?\uE991) ("..<" . ?\uE992)
                (".>" . ?\uE993) (".~"  . ?\uE994) (".="  . ?\uE995)
                ;; /
                ("/*"  . ?\uE9A0) ("//"  . ?\uE9A1) ("/>"  . ?\uE9A2)
                ("/="  . ?\uE9A3) ("/==" . ?\uE9A4) ("///" . ?\uE9A5)
                ("/**" . ?\uE9A6)
                ;; :
                (":::" . ?\uE9AF) ("::"  . ?\uE9B0) (":="  . ?\uE9B1)
                (":≡"  . ?\uE9B2) (":>"  . ?\uE9B3) (":=>" . ?\uE9B4)
                (":("  . ?\uE9B5) (":-(" . ?\uE9B6) (":)"  . ?\uE9B7)
                (":-)" . ?\uE9B8) (":/"  . ?\uE9B9) (":\\" . ?\uE9BA)
                (":3"  . ?\uE9BB) (":D"  . ?\uE9BC) (":P"  . ?\uE9BD)
                (":>:" . ?\uE9BE) (":<:" . ?\uE9BF)
                ;; <
                ("<$>"  . ?\uE9C0) ("<*"  . ?\uE9C1) ("<*>"  . ?\uE9C2)
                ("<+>"  . ?\uE9C3) ("<-"  . ?\uE9C4) ("<<"   . ?\uE9C5)
                ("<<<"  . ?\uE9C6) ("<<=" . ?\uE9C7) ("<="   . ?\uE9C8)
                ("<=>"  . ?\uE9C9) ("<>"  . ?\uE9CA) ("<|>"  . ?\uE9CB)
                ("<<-"  . ?\uE9CC) ("<|"  . ?\uE9CD) ("<=<"  . ?\uE9CE)
                ("<~"   . ?\uE9CF) ("<~~" . ?\uE9D0) ("<<~"  . ?\uE9D1)
                ("<$"   . ?\uE9D2) ("<+"  . ?\uE9D3) ("<!>"  . ?\uE9D4)
                ("<@>"  . ?\uE9D5) ("<#>" . ?\uE9D6) ("<%>"  . ?\uE9D7)
                ("<^>"  . ?\uE9D8) ("<&>" . ?\uE9D9) ("<?>"  . ?\uE9DA)
                ("<.>"  . ?\uE9DB) ("</>" . ?\uE9DC) ("<\\>" . ?\uE9DD)
                ("<\">" . ?\uE9DE) ("<:>" . ?\uE9DF) ("<~>"  . ?\uE9E0)
                ("<**>" . ?\uE9E1) ("<<^" . ?\uE9E2) ("<!"   . ?\uE9E3)
                ("<@"   . ?\uE9E4) ("<#"  . ?\uE9E5) ("<%"   . ?\uE9E6)
                ("<^"   . ?\uE9E7) ("<&"  . ?\uE9E8) ("<?"   . ?\uE9E9)
                ("<."   . ?\uE9EA) ("</"  . ?\uE9EB) ("<\\"  . ?\uE9EC)
                ("<\""  . ?\uE9ED) ("<:"  . ?\uE9EE) ("<->"  . ?\uE9EF)
                ("<!--" . ?\uE9F0) ("<--" . ?\uE9F1) ("<~<"  . ?\uE9F2)
                ("<==>" . ?\uE9F3) ("<|-" . ?\uE9F4) ("<||"  . ?\uE9F5)
                ("<<|"  . ?\uE9F6) ("<-<" . ?\uE9F7) ("<-->" . ?\uE9F8)
                ("<<==" . ?\uE9F9) ("<==" . ?\uE9FA)
                ;; =
                ("=<<"  . ?\uEA00) ("=="  . ?\uEA01) ("===" . ?\uEA02)
                ("==>"  . ?\uEA03) ("=>"  . ?\uEA04) ("=~"  . ?\uEA05)
                ("=>>"  . ?\uEA06) ("=/=" . ?\uEA07) ("=~=" . ?\uEA08)
                ("==>>" . ?\uEA09) ("=>=" . ?\uEA0A) ("=<=" . ?\uEA0B)
                ("=<"   . ?\uEA0C)
                ;; ≡
                ("≡≡" . ?\uEA10) ("≡≡≡" . ?\uEA11) ("≡:≡" . ?\uEA12)
                ;; >
                (">-"  . ?\uEA20) (">="  . ?\uEA21) (">>"  . ?\uEA22)
                (">>-" . ?\uEA23) (">>=" . ?\uEA24) (">>>" . ?\uEA25)
                (">=>" . ?\uEA26) (">>^" . ?\uEA27) (">>|" . ?\uEA28)
                (">!=" . ?\uEA29) (">->" . ?\uEA2A)
                ;; ?
                ("??" . ?\uEA40) ("?~"  . ?\uEA41) ("?=" . ?\uEA42)
                ("?>" . ?\uEA43) ("???" . ?\uEA44) ("?." . ?\uEA45)
                ;; ^
                ("^="  . ?\uEA48) ("^."  . ?\uEA49) ("^?"  . ?\uEA4A)
                ("^.." . ?\uEA4B) ("^<<" . ?\uEA4C) ("^>>" . ?\uEA4D)
                ("^>"  . ?\uEA4E)
                ;; \
                ("\\\\" . ?\uEA50) ("\\>" . ?\uEA51) ("\\/-" . ?\uEA52)
                ;; @
                ("@>" . ?\uEA57)
                ;; |
                ("|="   . ?\uEA60) ("||"  . ?\uEA61) ("|>"   . ?\uEA62)
                ("|||"  . ?\uEA63) ("|+|" . ?\uEA64) ("|->"  . ?\uEA65)
                ("|-->" . ?\uEA66) ("|=>" . ?\uEA67) ("|==>" . ?\uEA68)
                ("|>-"  . ?\uEA69) ("|<<" . ?\uEA6A) ("||>"  . ?\uEA6B)
                ("|>>"  . ?\uEA6C) ("|-"  . ?\uEA6D) ("||-"  . ?\uEA6E)
                ;; ~
                ("~="  . ?\uEA70) ("~>" . ?\uEA71) ("~~>" . ?\uEA72)
                ("~>>" . ?\uEA73)
                ;; [
                ("[[" . ?\uEA80) ("]]" . ?\uEA81)
                ;; "
                ("\">" . ?\uEA90)
                ;; _
                ("_|_" . ?\uEA97))))))
      (append pragmata safe))
    "Alist of pretty symbol to composition specification pairs.")

  (defun koek-ps/make-enable (&rest symbols)
    "Return function to setup and enable function `prettify-symbols-mode'.
  SYMBOLS are one or more pretty symbol pairs and/or pretty
  symbols.

  Pretty symbol pair is a cons. Its car is a string, the symbol to
  replace. Its cdr is a key in `koek-ps/comp-specs', the symbol to
  replace it with. When both symbols are identical, prefer a pretty
  symbol.

  Pretty symbol is a key in `koek-ps/comp-specs'."
    (let ((specs (seq-reduce
                  (lambda (specs symbol)
                    (unless (consp symbol)
                      (setq symbol (cons symbol symbol)))
                    (pcase-let ((`(,from . ,to) symbol))
                      (when-let ((spec (cdr (assoc to koek-ps/comp-specs))))
                        (push (cons from spec) specs)))
                    specs)
                  symbols ())))
      (lambda ()
        (setq prettify-symbols-alist specs)
        (prettify-symbols-mode))))

  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (add-hook 'c-mode-hook
            (koek-ps/make-enable
             "!=" "%=" "&&" "&=" "*=" "++" "+=" "--" "-=" "->" "/=" "<<" "<=" "=="
             ">=" ">>" "^=" "|=" "||"))
  (add-hook 'c++-mode-hook
            (koek-ps/make-enable
             "!=" "%=" "&&" "&=" "*=" "++" "+=" "--" "-=" "->" "/=" "::" "<<" "<="
             "==" ">=" ">>" "^=" "|=" "||"))
  (add-hook 'clojure-mode-hook
            (koek-ps/make-enable '("fn" . "lambda") "->" "->>" "<=" ">="))
  (add-hook 'lisp-mode-hook
            (koek-ps/make-enable "lambda" "<=" ">="))
  (add-hook 'emacs-lisp-mode-hook
            (koek-ps/make-enable "lambda" "<=" ">="))
  (add-hook 'erlang-mode-hook
            (koek-ps/make-enable "->" '("=<" . "<=") ">="))
  (add-hook 'java-mode-hook
            (koek-ps/make-enable
             "!=" "%=" "&&" "&=" "*=" "++" "+=" "--" "-=" "/=" "<<" "<=" "==" ">="
             ">>" ">>>" "^=" "|=" "||"))
  (add-hook 'js2-mode-hook
            (koek-ps/make-enable
             "function" "!!" "!=" "!==" "%=" "&&" "&=" "*=" "++" "+=" "--" "-="
             "..." "/=" "<<" "<=" "==" "===" "=>" ">=" ">>" ">>>" "^=" "|=" "||"))
  (add-hook 'octave-mode-hook
            (koek-ps/make-enable "&&" "<=" "==" ">=" "||" "~="))
  (add-hook 'scad-mode-hook
            (koek-ps/make-enable "!=" "&&" "<=" "==" ">=" "||"))
  (add-hook 'python-mode-hook
            (koek-ps/make-enable "!=" "//" "<<" "<=" "==" ">=" ">>"))
  (add-hook 'scheme-mode-hook
            (koek-ps/make-enable "lambda" "<=" ">="))
  (add-hook 'sql-mode-hook
            (koek-ps/make-enable "::" "<=" "<>" ">="))
#+END_SRC

** Whitespace
Indent with spaces, not tabs.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

End sentences with single space, not double space.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

End files with empty line.

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)

  (defun koek-ws/disable-final-empty-line ()
    "Disable final empty line for current."
    (setq-local require-final-newline nil))

  (add-hook 'snippet-mode-hook #'koek-ws/disable-final-empty-line)
#+END_SRC

** whitespace - Clean & visualize whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :hook ((prog-mode conf-mode) . whitespace-mode)
    :config
    (setq whitespace-action '(auto-cleanup))
    (setq whitespace-style '(face trailing empty lines-tail))
    :delight)
#+END_SRC

*** Issues

**** Modifying display table affects overlays
#+BEGIN_SRC emacs-lisp :tangle no
  (setq whitespace-style '(space-mark tab-mark newline-mark))
#+END_SRC

** Edit commands
Supercharge edit commands.

#+BEGIN_SRC emacs-lisp
  (bind-key [remap downcase-word] #'downcase-dwim)
  (bind-key [remap upcase-word] #'upcase-dwim)
  (bind-key [remap capitalize-word] #'capitalize-dwim)
#+END_SRC

** Clipboard
Add clipboard to kill ring before killing.

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+END_SRC

** Complete text
When line is indented, press =TAB= to complete text before point.

#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC

** company - Autocomplete code
[[https://github.com/company-mode/company-mode][company (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :bind
    (:map company-mode-map
     ;; Why does [remap indent-for-tab-command] only work in prog-mode?
     ("TAB" . company-indent-or-complete-common)
     :map company-active-map
     ("C-n" . company-select-next)
     ("C-p" . company-select-previous))
    :hook ((prog-mode conf-mode comint-mode cider-repl-mode) . company-mode)
    :preface
    (defun koek-cpny/make-setup-backends (backends)
      "Return function to setup backends for current.
  BACKENDS is a list of backends, see `company-backends'."
      (lambda ()
        (setq-local company-backends backends)))

    ;; Prevent geiser from modifying company-backends
    (define-advice geiser-company--setup-company
        (:around (f &rest args) koek-cpny/disable-setup-backends)
      (let ((backends company-backends))
        (apply f args)
        (setq company-backends backends)))
    :config
    (setq company-backends
          '((company-capf company-files :with company-yasnippet)))
    (setq company-idle-delay 1)           ; In seconds
    (setq company-show-numbers t)

    ;; Setup mode specific backends
    (add-hook 'indium-repl-mode-hook
              (koek-cpny/make-setup-backends
               '((company-indium-repl company-files :with company-yasnippet))))
    (let ((setup-geiser-backend
           (koek-cpny/make-setup-backends
            '((geiser-company-backend company-files :with company-yasnippet)))))
      (add-hook 'geiser-mode-hook setup-geiser-backend)
      (add-hook 'geiser-repl-mode-hook setup-geiser-backend))
    (let ((setup-code-backend
           (koek-cpny/make-setup-backends
            '((company-dabbrev-code company-files :with company-yasnippet)))))
      (add-hook 'erlang-mode-hook setup-code-backend)
      (add-hook 'scad-mode-hook setup-code-backend))
    (let ((setup-dabbrev-backend
           (koek-cpny/make-setup-backends
            '((company-dabbrev company-files :with company-yasnippet)))))
      (add-hook 'conf-mode-hook setup-dabbrev-backend))
    :delight)

  (use-package company-dabbrev
    :defer t
    :config
    (setq company-dabbrev-other-buffers t)) ; Same major mode
#+END_SRC

*** company-flx - Match candidates fuzzily
[[https://github.com/PythonNut/company-flx][company-flx (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package company-flx
    :ensure t
    :after company
    :config
    (company-flx-mode))
#+END_SRC

** eglot - Code insight
[[https://github.com/joaotavora/eglot][eglot (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :ensure t
    :bind
    (:map eglot-mode-map
     ("C-c r f" . eglot-code-actions)
     ("C-c r r" . eglot-rename)
     ("C-c C-d" . eglot-help-at-point))
    :hook
    ((c-mode c++-mode mhtml-mode css-mode java-mode js2-mode json-mode
      python-mode)
     . eglot-ensure)
    :config
    ;; Eclipse JDT Language Server lacks an executable. Eglot requires
    ;; the jdtls launcher to be added to the CLASSPATH environment
    ;; variable.
    (when-let
        ((launcher-program-name
          (thread-last '("/usr/share/java/jdtls/plugins/" "c:/bin/jdtls/plugins/")
            (seq-filter #'file-exists-p)
            (seq-mapcat (lambda (file-name)
                          (directory-files file-name 'full
                                           (rx "org.eclipse.equinox.launcher_"
                                               (one-or-more (or alnum punct))
                                               ".jar" line-end))))
            car)))
      (let ((paths (split-string (or (getenv "CLASSPATH") "")
                                 path-separator 'omit-nulls)))
        (unless (member launcher-program-name paths)
          (setenv "CLASSPATH"
                  (string-join (cons launcher-program-name paths)
                               path-separator)))))

    ;; Register additional language servers
    (push '((c-mode c++-mode) . ("clangd")) eglot-server-programs)
    (push '(mhtml-mode . ("html-languageserver" "--stdio")) eglot-server-programs)
    (push '(css-mode . ("css-languageserver" "--stdio")) eglot-server-programs)
    (push '(json-mode . ("json-languageserver" "--stdio")) eglot-server-programs))

  (use-package flymake
    :bind
    (:map flymake-mode-map
     ("C-c ! n" . flymake-goto-next-error)
     ("C-c ! p" . flymake-goto-prev-error)
     ("C-c ! l" . flymake-show-diagnostics-buffer))
    :config
    (setq flymake-wrap-around nil)
    :delight)

  (use-package flymake-proc
    :defer t
    :config
    (declare-function flymake-proc-legacy-flymake "flymake-proc")

    (remove-hook 'flymake-diagnostic-functions #'flymake-proc-legacy-flymake))
#+END_SRC

*** Setting up Clang
Run =M-x= ~make-symbolic-link~. Create a link to
=compile_commands.json= in the project home directory.

** xref - Jump to definition & references
#+BEGIN_SRC emacs-lisp
  (use-package xref
    :defer t
    :config
    (add-to-list 'xref-prompt-for-identifier #'xref-find-references 'append))
#+END_SRC

** abbrev - Abbreviations
#+BEGIN_SRC emacs-lisp
  (use-package abbrev
    :hook ((sql-mode sql-interactive-mode) . abbrev-mode)
    :config
    (declare-function find-library-name "find-func")

    ;; Prime abbrev tables
    (unless (file-exists-p (no-littering-expand-var-file-name "abbrev.el"))
      ;; Upcase SQL keywords
      (let ((abbrevs
             (let ((keywords
                    (split-string
                     (with-temp-buffer
                       (insert-file-contents (find-library-name "sql"))
                       (search-forward "ANSI Reserved keywords")
                       (buffer-substring (re-search-forward
                                          (rx (one-or-more (not (any "\"")))))
                                         (re-search-forward
                                          (rx (one-or-more (not (any ")")))))))
                     (rx (any " \n")) 'omit-nulls "\"")))
               (mapcar (lambda (keyword)
                         (list keyword (upcase keyword)))
                       keywords))))
        (define-abbrev-table 'sql-mode-abbrev-table abbrevs)
        (define-abbrev-table 'sql-interactive-mode-abbrev-table abbrevs)))

    (setq save-abbrevs 'silently)
    :delight)
#+END_SRC

** yasnippet - Snippets
[[https://github.com/joaotavora/yasnippet][yasnippet (GitHub)]]

For the major mode, see [[*YASnippet][YASnippet]].

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :hook ((text-mode prog-mode conf-mode) . yas-minor-mode)
    :config
    (declare-function koek-org/get-src-block-var-value "50-general")
    (declare-function koek-ys/get-org-name "50-general")
    (declare-function projectile-project-p "projectile")
    (declare-function projectile-project-root "projectile")
    (declare-function yas-choose-value "yasnippet")
    (declare-function yas-reload-all "yasnippet")

    ;; Snippet odds and ends
    (defun koek-ys/indent-snippet ()
      "Indent last expanded snippet.
  Snippet is between `yas-snippet-beg' and `yas-snippet-end'."
      (indent-region yas-snippet-beg yas-snippet-end))

    (defun koek-ys/complete-field (candidates)
      "Complete field from CANDIDATES.
  CANDIDATES is an alist of pretty candidate to candidate pairs."
      (cdr (assoc (yas-choose-value (mapcar #'car candidates)) candidates)))

    (defun koek-ys/determine-ns-name ()
      "Return Clojure namespace name for current.
  Assumes source path is a child of project root."
      (let ((parts
             (let ((separator (thread-first (expand-file-name "a" "b")
                                file-relative-name
                                (substring 1 2)))
                   (rel-file-name
                    (let ((file-name (buffer-file-name)))
                      (if (and (projectile-project-p) file-name)
                          (file-relative-name (file-truename file-name)
                                              (projectile-project-root))
                        (buffer-name)))))
               (let ((file-name (file-name-sans-extension rel-file-name)))
                 (or (cdr (split-string file-name (regexp-quote separator)))
                     (list file-name))))))
        (string-join
         (mapcar (apply-partially #'replace-regexp-in-string "_" "-") parts) ".")))

    (defconst koek-ys/ietf-languages
      '(("de-DE" . ("de-de" "ngerman"  "de_DE"))
        ("en-US" . ("en-us" "american" "en_US"))
        ("fr-FR" . ("fr"    "frenchb"  "fr_FR"))
        ("nl-BE" . ("nl"    "dutch"    "nl_BE")))
      "Alist of IETF language pairs.
  IETF language pair is a cons.  Its car is a string, an IETF
  language name.  Its cdr is a list of strings, an Org language
  name, a LaTeX language name and a Hunspell language name.")

    (fset 'koek-ys/get-org-name (apply-partially #'nth 0))
    (fset 'koek-ys/get-latex-name (apply-partially #'nth 1))
    (fset 'koek-ys/get-hunspell-name (apply-partially #'nth 2))
    (let ((map (mapcar (pcase-lambda (`(,ietf . ,spec))
                         (cons (koek-ys/get-org-name spec) ietf))
                       koek-ys/ietf-languages)))
      (fset 'koek-ys/org-to-ietf (lambda (org)
                                   (cdr (assoc org map)))))

    (defun koek-ys/make-ensure-result-directory (var-name)
      "Return function to ensure result directory of current source block exists.
  VAR-NAME is a string, the variable name which stores the result
  file name."
      (lambda ()
        (when-let
            ((file-name (when-let
                            ((value (koek-org/get-src-block-var-value var-name)))
                          (file-name-directory
                           (replace-regexp-in-string (rx (or (and line-start "\"")
                                                             (and "\"" line-end)))
                                                     "" value)))))
          (when-let ((file-name-root (buffer-file-name)))
            (setq file-name
                  (expand-file-name file-name
                                    (file-name-directory file-name-root))))
          (when (file-name-absolute-p file-name)
            (make-directory file-name 'parents)))))

    ;; Load own snippets
    (setq yas-snippet-dirs (delq 'yas-installed-snippets-dir yas-snippet-dirs))
    (yas-reload-all)

    ;; Set new snippet file snippet
    (with-temp-buffer
      (insert-file-contents
       (expand-file-name "yasnippet/snippets/snippet-mode/new"
                         no-littering-etc-directory))
      (setq yas-new-snippet-default
            (buffer-substring (re-search-forward (rx line-start "# --\n"))
                              (point-max))))
    :delight yas-minor-mode)
#+END_SRC

** undo-tree - Undo & redo replacement
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :demand t
    :bind
    (:map undo-tree-map
     ("M-/" . undo-tree-redo))
    :config
    (global-undo-tree-mode)
    :delight)
#+END_SRC

** ispell - Spell checker
#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :defer t
    :config
    (setq ispell-program-name "hunspell")
    (let ((dictionary-name "en_US"))
      ;; On Windows, Hunspell requires the DICTIONARY environment
      ;; variable to be set
      (when (eq system-type 'windows-nt)
        (setenv "DICTIONARY" dictionary-name))
      (setq ispell-dictionary dictionary-name)))
#+END_SRC

** flycheck - Show syntax & style errors
[[https://github.com/flycheck/flycheck][flycheck (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :hook ((emacs-lisp-mode erlang-mode) . flycheck-mode)
    :config
    (setq flycheck-emacs-lisp-load-path 'inherit)
    :delight)
#+END_SRC

*** flycheck-jslint - JSLint checker
[[https://github.com/Koekelas/jslint-cli][flycheck-jslint (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-jslint
    :load-path "lisp/jslint-cli/"
    :after (:all flycheck (:any js2-mode json-mode)))
#+END_SRC

* Windows & buffers

** Windows
Resize windows pixelwise, not characterwise.

#+BEGIN_SRC emacs-lisp
  (setq window-resize-pixelwise t)
#+END_SRC

** Window commands
The default keybindings assume a QWERTY keyboard layout. Some
keybindings are clunky on other keyboard layouts. Rebind clunky window
commands.

#+BEGIN_SRC emacs-lisp
  (bind-keys
   ("C-c w h" . split-window-below)
   ("C-c w v" . split-window-right)
   ("C-c w b" . balance-windows)
   ("C-c w d" . delete-window)
   ("C-c w C-d" . delete-other-windows))
#+END_SRC

Resizing a window by characters or pixels is slow. Resize windows in
steps.

#+BEGIN_SRC emacs-lisp
  (defconst koek-wind/n-hor-steps 32
    "Number of horizontal steps to resize a window from monitor width to zero.")

  (defun koek-wind/resize (shrink vertical)
    "Resize selected window.
  Unless SHRINK is nil, shrink window, else, grow window.  Unless
  VERTICAL is nil, resize vertically, else, resize horizontally."
    (let* ((geometry (frame-monitor-attribute 'geometry))
           (width (nth 2 geometry))
           (step (/ width koek-wind/n-hor-steps))
           (delta (if shrink
                      (* step -1)
                    step)))
      (window-resize nil delta (not vertical) nil 'pixelwise)))

  (defun koek-wind/grow (&optional arg)
    "Grow selected window.
  With `\\[universal-argument]' prefix argument ARG, grow
  vertically, else, grow horizontally."
    (interactive "P")
    (koek-wind/resize nil arg))

  (defun koek-wind/shrink (&optional arg)
    "Shrink selected window.
  With `\\[universal-argument]' prefix argument ARG, shrink
  vertically, else, shrink horizontally."
    (interactive "P")
    (koek-wind/resize 'shrink arg))

  (bind-keys
   ("C-c w g" . koek-wind/grow)
   ("C-c w s" . koek-wind/shrink))
#+END_SRC

** ace-window - Jump to window
[[https://github.com/abo-abo/ace-window][ace-window (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :bind
    ([remap other-window] . ace-window)
    :config
    (setq aw-swap-invert t)
    (setq aw-keys '(?q ?s ?d ?f ?j ?k ?l ?m))
    (setq aw-dispatch-alist '((?o aw-flip-window)))
    (setq aw-leading-char-style 'path)
    ;; When there are two windows, ace chooses the other window. When
    ;; there are three or more windows, ace asks for a window. Enabling
    ;; background (default) differentiates both cases. Don't disable
    ;; background when jumping to a window.
    ;; (setq aw-background nil)
    ;; Ace isn't a minor mode but it can be delighted [sic]
    :delight)
#+END_SRC

** transpose-frame - Transform window layout
[[https://github.com/emacsorphanage/transpose-frame][transpose-frame (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind
    ("C-c w t" . transpose-frame)
    :commands
    (flip-frame flop-frame rotate-frame-clockwise rotate-frame-anticlockwise)
    :preface
    (defun koek-tf/flip (&optional arg)
      "Flip window layout.
  With `\\[universal-argument]' prefix argument ARG, flip
  vertically, else, flip horizontally."
      (interactive "P")
      (if arg
          (flip-frame)
        (flop-frame)))

    (defun koek-tf/rotate (&optional arg)
      "Rotate window layout.
  With `\\[universal-argument]' prefix argument ARG, rotate
  counterclockwise, else, rotate clockwise."
      (interactive "P")
      (if arg
          (rotate-frame-anticlockwise)
        (rotate-frame-clockwise)))
    :init
    (bind-keys
     ("C-c w f" . koek-tf/flip)
     ("C-c w c" . koek-tf/rotate)))
#+END_SRC

** winner - Undo & redo window layout changes
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :demand t
    :bind
    (("C-c w l" . winner-undo)
     ("C-c w r" . winner-redo))
    :config
    (declare-function winner-save-unconditionally "winner")

    (winner-mode)

    ;; Reading from the minibuffer doesn't change the window layout.
    ;; Storing the window layout when it didn't change, stores a
    ;; consecutive identical layout. Don't store the window layout when
    ;; reading from the minibuffer.
    (remove-hook 'minibuffer-setup-hook #'winner-save-unconditionally))
#+END_SRC

** eyebrowse - Workspaces
[[https://github.com/wasamasa/eyebrowse][eyebrowse (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :ensure t
    :bind
    (("C-c w 1" . eyebrowse-switch-to-window-config-1)
     ("C-c w 2" . eyebrowse-switch-to-window-config-2)
     ("C-c w 3" . eyebrowse-switch-to-window-config-3)
     ("C-c w 4" . eyebrowse-switch-to-window-config-4)
     ("C-c w 5" . eyebrowse-switch-to-window-config-5)
     ("C-c w 6" . eyebrowse-switch-to-window-config-6)
     ("C-c w 7" . eyebrowse-switch-to-window-config-7)
     ("C-c w 8" . eyebrowse-switch-to-window-config-8)
     ("C-c w 9" . eyebrowse-switch-to-window-config-9)
     ("C-c w w" . eyebrowse-last-window-config)
     ("C-c w k" . eyebrowse-close-window-config))
    :config
    ;; Resolve keybinding conflict with org
    (setq minor-mode-map-alist
          (assq-delete-all 'eyebrowse-mode minor-mode-map-alist))

    (setq eyebrowse-mode-line-style 'hide)
    (eyebrowse-mode))
#+END_SRC

** uniquify - Descriptive buffer names
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config
    (setq uniquify-buffer-name-style 'forward)
    (setq uniquify-trailing-separator-p t))
#+END_SRC

** ibuffer - list-buffers replacement
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind
    ([remap list-buffers] . ibuffer))
#+END_SRC

** Buffer commands
Bury unneeded buffers, computers have more than enough memory.

#+BEGIN_SRC emacs-lisp
  (defun koek-buff/bury (&optional arg)
    "Bury current.
  With `\\[universal-argument]' prefix argument ARG, kill current."
    (interactive "P")
    (if arg
        (kill-buffer)
      (bury-buffer)))

  (bind-key [remap kill-buffer] #'koek-buff/bury)
#+END_SRC

* Other

** Minibuffer
Enable minibuffer commands (e.g. [[*counsel - Ivy powered commands][counsel]]) in minibuffer.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

** ivy - completing-read replacement
[[https://github.com/abo-abo/swiper][ivy (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :demand t
    :bind
    (("C-r" . ivy-resume)
     :map ivy-minibuffer-map
     ("C-c j" . ivy-avy))
    :config
    ;; When counsel loads, various commands setup initial input
    (use-package counsel
      :defer t
      :config
      (setq ivy-initial-inputs-alist nil))

    (setq ivy-re-builders-alist
          '((swiper-isearch . ivy--regex-plus)
            (counsel-ag . ivy--regex-plus)
            (counsel-unicode-char . ivy--regex-ignore-order)
            (t . ivy--regex-fuzzy)))
    (setq ivy-use-virtual-buffers t)
    (setq ivy-virtual-abbreviate 'abbreviate)
    (setq ivy-use-selectable-prompt t)
    (setq ivy-count-format "%d/%d ")
    (ivy-mode)
    :delight)

  ;; Optional dependencies
  (koek-pkg/ensure 'flx)
  (koek-pkg/ensure 'wgrep)
#+END_SRC

*** counsel - Ivy powered commands
[[https://github.com/abo-abo/swiper][counsel (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (([remap find-file] . counsel-find-file)
     ([remap insert-char] . counsel-unicode-char)
     ([remap yank-pop] . counsel-yank-pop)
     ([remap execute-extended-command] . counsel-M-x)
     ([remap info-lookup-symbol] . counsel-info-lookup-symbol)
     ("C-M-s" . counsel-ag)
     ("C-c f s" . counsel-file-jump)
     ("C-c f l" . counsel-find-library)
     ("C-c j d" . counsel-imenu)
     ("C-c j o" . counsel-org-goto-all)
     ("C-c x x" . counsel-linux-app)
     ("C-c x s" . counsel-search)
     :map minibuffer-local-map
     ("C-r" . counsel-minibuffer-history))
    :config
    (declare-function counsel-linux-app-format-function-name-first "counsel")
    (declare-function ivy-set-actions "ivy")
    (put 'counsel-ag-base-command 'safe-local-variable
         (lambda (value)
           (string= value "ag --nocolor --nogroup --hidden %s")))

    (let ((show-help (lambda (candidate)
                       (helpful-function (intern candidate)))))
      (ivy-set-actions 'counsel-M-x
                       `(("d" counsel--find-symbol "definition")
                         ("h" ,show-help "help"))))

    (setq counsel-linux-app-format-function
          #'counsel-linux-app-format-function-name-first)
    (setq counsel-org-goto-all-outline-path-prefix 'buffer-name)
    (setq counsel-outline-face-style 'org))

  (koek-pkg/ensure 'request)              ; Optional dependency
#+END_SRC

*** counsel-projectile - Ivy powered Projectile commands
[[https://github.com/ericdanan/counsel-projectile][counsel-projectile (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :after projectile
    :config
    (setq counsel-projectile-key-bindings
          (append counsel-projectile-key-bindings
                  `((,(kbd "C-p") . counsel-projectile-switch-project)
                    (,(kbd "p")   . counsel-projectile))))

    (counsel-projectile-mode))
#+END_SRC

** helpful - Help viewer
[[https://github.com/Wilfred/helpful][helpful (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    (([remap describe-variable] . helpful-variable)
     ([remap describe-function] . helpful-callable)
     ([remap describe-key] . helpful-key)))
#+END_SRC

** info - Info viewer
#+BEGIN_SRC emacs-lisp
  (use-package info
    :bind
    ("C-c d i" . info-apropos))
#+END_SRC

** man - Manual viewer
#+BEGIN_SRC emacs-lisp
  (use-package man
    :bind
    ("C-c d m" . man))
#+END_SRC

** apropos - Search Emacs environment
#+BEGIN_SRC emacs-lisp
  (use-package apropos
    :bind
    ("C-c d a" . apropos))
#+END_SRC

** devdocs-lookup - Search DevDocs
[[https://github.com/skeeto/devdocs-lookup][devdocs-lookup (GitHub)]]

On [[https://devdocs.io/][DevDocs]], enable:

- C
- C++
- Clojure
- CSS
- DOM
- DOM Events
- Erlang
- Express
- HTML
- JavaScript
- jQuery
- lodash
- Matplotlib
- Node.js
- npm
- NumPy
- Octave
- OpenJDK
- pandas
- PostgreSQL
- Python
- scikit-image
- scikit-learn
- StatsModels

#+BEGIN_SRC emacs-lisp
  (use-package devdocs-lookup
    :load-path "lisp/devdocs-lookup/"
    :bind
    ("C-c d d" . devdocs-lookup)
    :config
    (declare-function devdocs-setup "devdocs-lookup")

    ;; DevDocs is updated more frequently than devdocs-lookup. Update
    ;; subjects.
    (setq devdocs-subjects
          '(("C" "c")
            ("C++" "cpp")
            ("Clojure" "clojure~1.10")
            ("CSS" "css")
            ("DOM" "dom")
            ("DOM Events" "dom_events")
            ("Erlang" "erlang~21")
            ("Express" "express")
            ("HTML" "html")
            ("JavaScript" "javascript")
            ("jQuery" "jquery")
            ("lodash" "lodash~4")
            ("Matplotlib" "matplotlib~3.1")
            ("Node.js" "node")
            ("npm" "npm")
            ("NumPy" "numpy~1.17")
            ("Octave" "octave")
            ("OpenJDK" "openjdk~8")
            ("pandas" "pandas~0.25")
            ("PostgreSQL" "postgresql~11")
            ("Python" "python~3.7")
            ("scikit-image" "scikit_image")
            ("scikit-learn" "scikit_learn")
            ("StatsModels" "statsmodels")))
    (devdocs-setup))
#+END_SRC

** eldoc - Show docstring
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :commands eldoc-mode
    :delight)
#+END_SRC

** which-key - Show keybindings
[[https://github.com/justbur/emacs-which-key][which-key (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-add-key-based-replacements
      "C-c !" "errors"
      "C-c &" "yasnippet"
      "C-c d" "documentation"
      "C-c f" "files"
      "C-c j" "jump"
      "C-c o" "org"
      "C-c p" "projectile"
      "C-c r" "refactor"
      "C-c w" "windows"
      "C-c x" "other")

    ;; Resolve rename keybinding conflict with org
    (which-key-add-major-mode-key-based-replacements 'org-mode
      "C-c !" nil)

    (which-key-mode)
    :delight)
#+END_SRC

*** Issues

**** Sorting on description fails
#+BEGIN_SRC emacs-lisp :tangle no
  (setq which-key-sort-order 'which-key-description-order)
#+END_SRC

Prefix map =projectile= is sorted before prefix map =documentation=.

** eshell - Shell
#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :bind
    ("C-c x e" . eshell))

  (use-package esh-module
    :defer t
    :config
    (push 'eshell-smart eshell-modules-list))

  (use-package em-unix
    :defer t
    :config
    (setq eshell-mv-interactive-query t)
    (setq eshell-cp-interactive-query t)
    (setq eshell-ln-interactive-query t)
    (setq eshell-rm-interactive-query t))
#+END_SRC

** compile - Run asynchronous processes
#+BEGIN_SRC emacs-lisp
  (use-package compile
    :bind
    (("C-c x c" . compile)
     ("C-c x r" . recompile))
    :preface
    (declare-function ansi-color-apply-on-region "ansi-color")

    (defun koek-cmpl/style-output ()
      "Style process output.
  Output is between `compilation-filter-start' and point."
      (ansi-color-apply-on-region compilation-filter-start (point)))
    :config
    (setq compilation-scroll-output 'first-error)
    (add-hook 'compilation-filter-hook #'koek-cmpl/style-output))
#+END_SRC

** mu4e - E-mail client
[[https://github.com/djcb/mu][mu4e (GitHub)]]

For e-mail accounts, see [[file:90-personal.org::*E-mail accounts][E-mail accounts]].

#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :bind
    ("C-c x m" . mu4e))

  (use-package mu4e-vars
    :defer t
    :config
    (setq mu4e-get-mail-command "mbsync -a")
    (setq mu4e-update-interval (* 60 30)) ; In seconds
    ;; When moving e-mail, isync requires them to be renamed
    (setq mu4e-change-filenames-when-moving t)

    (setq mu4e-completing-read-function #'completing-read)
    (setq mu4e-context-policy 'pick-first)

    (setq mu4e-hide-index-messages t))

  (use-package mu4e-main
    :defer t
    :config
    (use-package mu4e-utils
      :bind
      (:map mu4e-main-mode-map
       ("G" . mu4e-update-mail-and-index)))) ; Mirror elfeed

  (use-package mu4e-headers
    :defer t
    :config
    (use-package mu4e-utils
      :bind
      (:map mu4e-headers-mode-map
       ("G" . mu4e-update-mail-and-index))))

  (use-package mu4e-mark
    :defer t
    :config
    (declare-function mu4e~mark-check-target "mu4e-mark")
    (declare-function mu4e~proc-move "mu4e-proc")

    ;; When trashing e-mail, e-mail is flagged trashed. E-mail flagged
    ;; trashed is deleted by most e-mail providers. Move to trash but
    ;; don't flag trashed.
    (setf (alist-get 'trash mu4e-marks)
          (plist-put
           (alist-get 'trash mu4e-marks)
           :action
           (lambda (docid _msg target)
             (mu4e~proc-move docid (mu4e~mark-check-target target) "-N")))))

  (use-package mu4e-view
    :defer t
    :config
    (use-package mu4e-utils
      :bind
      (:map mu4e-view-mode-map
       ("G" . mu4e-update-mail-and-index)))

    (use-package mu4e-actions
      :defer t
      :config
      (unless mu4e-msg2pdf
        (setq mu4e-view-actions
              (rassq-delete-all 'mu4e-action-view-as-pdf mu4e-view-actions))))

    (add-to-list 'mu4e-view-actions
                 '("open in browser" . mu4e-action-view-in-browser) 'append)
    (setq mu4e-view-show-addresses t))
#+END_SRC

** elfeed - News reader
[[https://github.com/skeeto/elfeed][elfeed (GitHub)]]

For news feeds, see [[file:90-personal.org::*News feeds][News feeds]].

#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    ("C-c x n" . elfeed))

  (use-package elfeed-search
    :defer t
    :config
    (setq elfeed-search-filter (concat elfeed-search-filter " ")))
#+END_SRC

** pdf-tools - PDF viewer
[[https://github.com/politza/pdf-tools][pdf-tools (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package pdf-view
    :ensure pdf-tools
    :mode ((rx ".pdf" string-end) . pdf-view-mode)
    :config
    ;; Only isearch is supported
    (use-package isearch
      :bind
      (:map pdf-view-mode-map
       ("C-s" . isearch-forward)))

    (setq-default pdf-view-display-size 'fit-page)
    :delight (pdf-view-mode "PDF" :major))

  (use-package pdf-links
    :bind
    (:map pdf-links-minor-mode-map
     ("C-c j j" . pdf-links-isearch-link)
     ("C-c j l" . pdf-links-action-perform)))

  (use-package pdf-loader
    :config
    (pdf-loader-install 'no-ask 'no-install-deps))
#+END_SRC

** calendar - Calendar
#+BEGIN_SRC emacs-lisp
  (use-package calendar
    :defer t
    :config
    (setq calendar-week-start-day 1))     ; Monday
#+END_SRC

* Languages

** Arduino
#+BEGIN_SRC emacs-lisp
  (defun koek-ino/get-in (keys alist)
    "Return value for KEYS in nested ALIST.
  KEYS is a list of keys."
    (if keys
        (koek-ino/get-in (cdr keys) (assq (car keys) alist))
      (cdr alist)))

  (defun koek-ino/set-in (keys value alist)
    "Set value for KEYS to VALUE in nested ALIST.
  KEYS is a list of keys."
    (when-let ((key (car keys)))
      (let ((pair (or (assq key alist)
                      (let ((new-pair (cons key ())))
                        (push new-pair alist)
                        new-pair))))
        (setcdr pair (if-let ((rem-keys (cdr keys)))
                         (koek-ino/set-in rem-keys value (cdr pair))
                       value))))
    alist)

  (defun koek-ino/extract-keys (compound-key)
    "Extract keys from COMPOUND-KEY.
  COMPOUND-KEY is a string of dot separated keys."
    (mapcar (lambda (key)
              (intern (concat ":" key)))
            (split-string compound-key (rx "."))))

  (defun koek-ino/make-nested-alist (properties)
    "Return nested alist.
  PROPERTIES is an alist of compound key to value pairs."
    (seq-reduce (pcase-lambda (alist `(,key . ,value))
                  (koek-ino/set-in (koek-ino/extract-keys key) value alist))
                properties ()))

  (defun koek-ino/read-properties (file-name)
    "Read properties from FILE-NAME."
    (let ((properties ()))
      (with-temp-buffer
        (insert-file-contents file-name)
        (while (re-search-forward         ; Matches across multiple lines
                (rx line-start
                    (submatch-n 1
                     (not (any "#\n")) (one-or-more (not (any "=")))) "="
                    (submatch-n 2 (one-or-more not-newline)) line-end)
                nil t)
          (push (cons (match-string 1) (match-string 2)) properties)))
      (koek-ino/make-nested-alist properties)))

  (defun koek-ino/read-hardware-specs (file-names)
    "Read hardware specifications from FILE-NAMES.
  FILE-NAMES is a list of file names to hardware specification
  install directories."
    (thread-last file-names
      (seq-mapcat
       (lambda (file-name)
         (file-expand-wildcards (expand-file-name "*/*/platform.txt" file-name)
                                'full)))
      (mapcar #'file-name-directory)
      (mapcar
       (lambda (file-name)
         `((:home        . ,file-name)
           (:boards      . ,(koek-ino/read-properties
                             (expand-file-name "boards.txt" file-name)))
           (:platform    . ,(koek-ino/read-properties
                             (expand-file-name "platform.txt" file-name)))
           (:programmers . ,(koek-ino/read-properties
                             (expand-file-name "programmers.txt" file-name))))))))

  (defun koek-ino/insert-section-heading (name)
    "Insert section heading into current.
  NAME is a string."
    (unless (= (point) 1)
      (insert "\n"))
    (insert "[" name "]\n"))

  (defun koek-ino/normalize-property-value (value)
    "Normalize property value VALUE.
  VALUE is a symbol, number, string or list.  Value is converted to
  a string."
    (cond
     ((listp value)
      (format "[%s]" (mapconcat #'koek-ino/normalize-property-value value ", ")))
     ((stringp value)
      (format "'%s'" value))
     (t
      (format "%s" value))))

  (defun koek-ino/insert-property (key value)
    "Insert property into current.
  KEY is a string.  VALUE is a symbol, number, string or list."
    (insert key " = " (koek-ino/normalize-property-value value) "\n"))

  (eval-and-compile
    (defun koek-ino/propertyp (element)
      "Return whether ELEMENT is a property."
      (not (keywordp element)))

    (defun koek-ino/normalize-sections-spec (spec &optional sections)
      "Normalize sections specification SPEC.
  SPEC is a list of section names and properties.  Specification is
  converted to a nested alist.  Keys are converted to strings.
  SECTIONS is used internally."
      (if spec
          (let ((section
                 (cons
                  (replace-regexp-in-string (rx line-start ":") ""
                                            (symbol-name (car spec)))
                  (mapcar (pcase-lambda (`(,key ,value))
                            (cons (symbol-name key) value))
                          (seq-partition
                           (seq-take-while #'koek-ino/propertyp (cdr spec)) 2)))))
            (koek-ino/normalize-sections-spec
             (seq-drop-while #'koek-ino/propertyp (cdr spec))
             (cons section sections)))
        (reverse sections))))

  (defmacro koek-ino/write-cross-file (file-name &rest spec)
    (declare (indent 1))
    `(with-temp-file ,file-name
       ,@(seq-mapcat (pcase-lambda (`(,name . ,properties))
                       (cons `(koek-ino/insert-section-heading ,name)
                             (mapcar (pcase-lambda (`(,key . ,value))
                                       `(koek-ino/insert-property ,key ,value))
                                     properties)))
                     (koek-ino/normalize-sections-spec spec))))

  (defconst koek-ino/hardware-install-dirs '("/usr/share/arduino/hardware/")
    "List of file names to hardware specification install directories.")

  (defconst koek-ino/hardware-whitelist-preds
    (list (lambda (spec)
            (let ((name (koek-ino/get-in '(:platform :name) spec))
                  (version (koek-ino/get-in '(:platform :version) spec)))
              (and (string= name "Arch Linux Arduino AVR Boards")
                   (string-match-p (rx line-start "1.6." (one-or-more num) line-end)
                                   version)
                   t))))
    "List of hardware specification whitelist predicates.
  Predicates are passed a hardware specification.  When a predicate
  returns t, the hardware specification is whitelisted.")

  (defun koek-ino/generate-project (file-name board-spec)
    "Generate Arduino project.
  FILE-NAME is a string, the file name to the project home
  directory.  BOARD-SPEC is an alist, the board specification.  It
  has two keys, :hardware and :board.  :hardware points to a
  hardware specification.  :board points to a board in :hardware."
    (interactive
     (list
      (thread-last (read-directory-name "Project home: ")
        expand-file-name
        file-name-as-directory)
      (let ((candidates
             (let ((hardware-specs
                    (seq-filter
                     (lambda (spec)
                       (seq-some (lambda (pred)
                                   (funcall pred spec))
                                 koek-ino/hardware-whitelist-preds))
                     (koek-ino/read-hardware-specs koek-ino/hardware-install-dirs))))
               (seq-mapcat
                (lambda (hardware-spec)
                  (let ((platform-name
                         (format "%s %s"
                                 (koek-ino/get-in '(:platform :name) hardware-spec)
                                 (koek-ino/get-in '(:platform :version) hardware-spec))))
                    (thread-last (koek-ino/get-in '(:boards) hardware-spec)
                      (mapcar #'cdr)
                      (seq-filter (apply-partially #'koek-ino/get-in '(:name)))
                      (mapcar (lambda (board-spec)
                                (cons (format "%s (%s)"
                                              (koek-ino/get-in '(:name) board-spec)
                                              platform-name)
                                      `((:board    . ,board-spec)
                                        (:hardware . ,hardware-spec))))))))
                hardware-specs))))
        (cdr (assoc (completing-read "Board: " candidates nil t) candidates)))))
    (make-directory file-name 'parents)
    (koek-ino/write-cross-file (expand-file-name "cross.txt" file-name)
      :binaries
      c (executable-find "avr-gcc")
      cpp (executable-find "avr-g++")
      :properties
      ino_src (directory-files
               (thread-last (koek-ino/get-in '(:hardware :home) board-spec)
                 (expand-file-name "cores/")
                 (expand-file-name
                  (koek-ino/get-in '(:board :build :core) board-spec))
                 file-name-as-directory)
               'full (rx (or ".c" ".cpp") line-end))
      :host_machine
      system "bare"))
#+END_SRC

** C family
#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :mode
    (((rx ".c" string-end) . c-mode)
     ((rx ".cpp" string-end) . c++-mode)
     ((rx ".java" string-end) . java-mode))
    :config
    (use-package devdocs-lookup
      :bind
      (:map c-mode-map
       ("C-c d d" . devdocs-lookup-c)
       :map c++-mode-map
       ("C-c d d" . devdocs-lookup-cpp)
       :map java-mode-map
       ("C-c d d" . devdocs-lookup-openjdk~8))))

  (use-package cc-cmds
    :defer t
    :preface
    (define-advice c-update-modeline
        (:around (f) koek-cc/disable-update-mode-name)
      (let ((name mode-name))
        (funcall f)
        (setq mode-name name))))

  (use-package cc-vars
    :defer t
    :config
    (setq c-default-style
          '((awk-mode  . "awk")
            (java-mode . "java")
            (other     . "stroustrup"))))
#+END_SRC

** Clojure & ClojureScript
[[https://github.com/clojure-emacs/clojure-mode][clojure-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure t
    :mode
    (((rx ".clj" string-end) . clojure-mode)
     ((rx ".cljs" string-end) . clojurescript-mode)
     ((rx ".cljc" string-end) . clojurec-mode)
     ((rx ".edn" string-end) . clojure-mode))
    :config
    (use-package devdocs-lookup
      :bind
      (:map clojure-mode-map
       ("C-c d d" . devdocs-lookup-clojure~1.10)))
    :delight
    (clojure-mode "Clj" :major)
    (clojurescript-mode "Cljs" :major)
    (clojurec-mode "Cljc" :major))
#+END_SRC

*** cider - Interact with process
[[https://github.com/clojure-emacs/cider][cider (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t
    :after clojure-mode)

  (use-package cider-mode
    :defer t
    :delight)

  (use-package cider-common
    :defer t
    :config
    (setq cider-prompt-for-symbol nil))

  (use-package cider-repl
    :defer t
    :config
    (setq cider-repl-use-pretty-printing t))
#+END_SRC

** Common Lisp
#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :mode (rx ".lisp" string-end))

  (use-package inf-lisp
    :after lisp-mode
    :config
    (setq inferior-lisp-program "sbcl"))
#+END_SRC

*** sly - Interact with process
[[https://github.com/joaotavora/sly][sly (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package sly
    :ensure t
    :after lisp-mode
    :preface
    (defun koek-sly/fix-install ()
      "Fix Sly install."
      (interactive)
      (byte-recompile-directory (file-name-directory (find-library-name "sly"))
                                nil 'force)))
#+END_SRC

*** Issues

**** Sly and Slynk versions differ
Run =M-x= ~koek-sly/fix-install~ and restart Emacs.

** Emacs Lisp
#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :mode ((rx ".el" string-end) . emacs-lisp-mode)
    :config
    (use-package pp
      :bind
      (:map emacs-lisp-mode-map
       ("C-c x p" . pp-eval-last-sexp)
       ("C-c x a" . pp-macroexpand-last-sexp)
       :map lisp-interaction-mode-map
       ("C-c x p" . pp-eval-last-sexp)
       ("C-c x a" . pp-macroexpand-last-sexp)))

    (use-package helpful
      :bind
      (:map emacs-lisp-mode-map
       ("C-c C-d" . helpful-at-point)
       :map lisp-interaction-mode-map
       ("C-c C-d" . helpful-at-point)))

    (bind-key "C-c C-c" #'eval-buffer emacs-lisp-mode-map)
    (bind-key "C-c C-c" #'eval-buffer lisp-interaction-mode-map)
    :delight (emacs-lisp-mode "El" :major))
#+END_SRC

** Erlang
[[https://github.com/erlang/otp][erlang (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package erlang
    :ensure t
    :mode ((rx ".erl" string-end) . erlang-mode)
    :config
    (use-package devdocs-lookup
      :bind
      (:map erlang-mode-map
       ("C-c d d" . devdocs-lookup-erlang~21)))

    ;; On Windows, executable-find finds the erlc shim. Shadow
    ;; c:/ProgramData/chocolatey/bin/.
    (when-let
        ((erlc-program-name
          ;; Assume only one version installed
          (car (file-expand-wildcards "c:/Program Files/erl*/bin/erlc.exe" '
                                      full))))
      (push (file-name-directory erlc-program-name) exec-path))
    (when-let ((erlc-program-name (executable-find "erlc")))
      (setq erlang-root-dir
            (locate-dominating-file (file-truename erlc-program-name) "bin")))
    :delight (erlang-mode "Erl" :major))
#+END_SRC

** HTML & CSS
#+BEGIN_SRC emacs-lisp
  (use-package mhtml-mode
    :mode (rx (or ".htm" ".html") string-end)
    :config
    (use-package devdocs-lookup
      :bind
      (:map mhtml-mode-map
       ("C-c d d" . devdocs-lookup-html)))
    :delight (mhtml-mode "HTML" :major))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode (rx ".css" string-end)
    :config
    (use-package devdocs-lookup
      :bind
      (:map css-mode-map
       ("C-c d d" . devdocs-lookup-css))))
#+END_SRC

*** emmet - Expand selector to HTML or CSS
[[https://github.com/smihica/emmet-mode][emmet-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :bind
    (:map emmet-mode-keymap
     ("C-<tab>" . emmet-expand-line))     ; Why does <tab> work but TAB not?
    :hook (mhtml-mode css-mode)
    :config
    (setq emmet-self-closing-tag-style " /")
    :delight)
#+END_SRC

** JavaScript
[[https://github.com/mooz/js2-mode][js2-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode (rx ".js" string-end)
    :interpreter "node"
    :config
    (use-package devdocs-lookup
      :bind
      (:map js2-mode-map
       ("C-c d d" . devdocs-lookup-javascript)
       ("C-c d C-d" . devdocs-lookup-dom)
       ("C-c d C-e" . devdocs-lookup-dom_events)
       ("C-c d C-j" . devdocs-lookup-jquery)
       ("C-c d C-l" . devdocs-lookup-lodash~4)
       ("C-c d C-n" . devdocs-lookup-node)
       ("C-c d C-p" . devdocs-lookup-npm)
       ("C-c d C-x" . devdocs-lookup-express)))

    ;; Resolve keybinding conflict with eglot
    (unbind-key "M-." js2-mode-map)

    (setq js2-mode-show-parse-errors nil)
    (setq js2-mode-show-strict-warnings nil)
    :delight (js2-mode "JS" :major))
#+END_SRC

*** indium - Interact with process
[[https://github.com/NicolasPetton/Indium][indium (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package indium-interaction
    :ensure indium
    :hook (js2-mode . indium-interaction-mode)
    :config
    ;; Resolve keybinding conflict with documentation keymap
    (unbind-key "C-c d" indium-interaction-mode-map)
    :delight)
#+END_SRC

** JSON
[[https://github.com/joshwnj/json-mode][json-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :mode (rx ".json" string-end)
    :config
    (use-package devdocs-lookup
      :bind
      (:map json-mode-map
       ("C-c d C-n" . devdocs-lookup-npm))))
#+END_SRC

** Markdown
[[https://github.com/jrblevin/markdown-mode][markdown-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (rx ".md" string-end)
    :config
    (setq markdown-command "pandoc -s -f markdown -t html5")
    (setq markdown-use-pandoc-style-yaml-metadata t)
    (setq markdown-asymmetric-header t)
    :delight (markdown-mode "MD" :major))
#+END_SRC

** Meson
[[https://github.com/wentasah/meson-mode][meson-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package meson-mode
    :ensure t
    :mode (rx "meson.build" string-end))
#+END_SRC

** Octave & MATLAB
#+BEGIN_SRC emacs-lisp
  (use-package octave
    :mode ((rx ".m" string-end) . octave-mode)
    :config
    (use-package devdocs-lookup
      :bind
      (:map octave-mode-map
       ("C-c d d" . devdocs-lookup-octave)))

    ;; Insert MATLAB compatible comments
    (setq octave-comment-char ?%)
    (setq octave-comment-start (char-to-string octave-comment-char))
    (setq octave-block-comment-start
          (concat (make-string 2 octave-comment-char) " "))

    (setq octave-blink-matching-block nil)
    :delight (octave-mode "M" :major))
#+END_SRC

** OpenSCAD
[[https://github.com/openscad/openscad][scad-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package scad-mode
    :ensure t
    :mode (rx ".scad" string-end)
    :config
    ;; Resolve smartparens' delayed post handlers not being called
    (unbind-key "<return>" scad-mode-map) ; Why does <return> work but RET not?

    (setq scad-indent-style "stroustrup"))
#+END_SRC

*** Issues

**** Built-in indentation styles are inappropriate for multiple line vectors
See [[info:ccmode#Customizing Indentation][Customizing Indentation (info)]].

** Org
For agendas, see [[file:90-personal.org::*Agendas][Agendas]].

#+BEGIN_SRC emacs-lisp
  (use-package org
    :mode ((rx ".org" string-end) . org-mode)
    :bind
    (("C-c o l" . org-store-link)
     :map org-mode-map
     ("C-M-f" . org-forward-heading-same-level)
     ("C-M-b" . org-backward-heading-same-level)
     ("C-M-n" . org-next-visible-heading)
     ("C-M-p" . org-previous-visible-heading)
     ("C-M-a" . org-previous-block)
     ("C-M-e" . org-next-block))
    :hook (org-mode . org-cdlatex-mode)
    :preface
    (defun koek-org/setup-tag-completion ()
      "Setup tag completion for current.
  Candidates are collected from agenda files."
      (setq-local org-complete-tags-always-offer-all-agenda-tags t))

    ;; Setup resume clock after showing initial buffer
    (add-hook 'window-setup-hook #'org-clock-persistence-insinuate)
    :config
    (declare-function org-redisplay-inline-images "org")

    (use-package avy
      :bind
      (:map org-mode-map
       ("C-c j h" . avy-org-goto-heading-timer)))

    (use-package counsel
      :bind
      (:map org-mode-map
       ([remap org-set-tags-command] . counsel-org-tag)))

    (use-package org-clock
      :bind
      (:map org-mode-map
       ("C-c o i" . org-clock-in)))

    (use-package outline
      :bind
      (:map org-mode-map
       ("C-M-u" . outline-up-heading)))

    ;; Headings, keywords & tags
    (setq org-outline-path-complete-in-steps nil)
    (setq org-refile-use-outline-path 'buffer-name)
    (setq org-todo-keywords
          '((sequence "TODO(t)" "STALLED(s@/!)" "|" "DONE(d!)" "ABANDONED(a@)")))
    (add-hook 'org-capture-mode-hook #'koek-org/setup-tag-completion)

    ;; Other
    (org-babel-do-load-languages 'org-babel-load-languages
                                 '((C . t) ; C and C++
                                   (clojure . t)
                                   (lisp . t)
                                   (emacs-lisp . t)
                                   (java . t)
                                   (js . t)
                                   (octave . t)
                                   (python . t)
                                   (scheme . t)
                                   (sql . t)))

    ;; Appearance
    (setq org-adapt-indentation nil)
    (setq org-highlight-latex-and-related '(native))

    ;; Appearance - Images
    (setq org-startup-with-inline-images t)
    (let ((width (thread-last (display-monitor-attributes-list)
                   car                   ; Primary display
                   (alist-get 'geometry) ; Arrangement/resolution
                   (nth 2))))            ; Width
      (setq org-image-actual-width (floor (* width (/ 1 5.0)))))
    (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)

    ;; Appearance - LaTeX previews
    (setq org-startup-with-latex-preview t)
    (setq org-preview-latex-image-directory
          (no-littering-expand-var-file-name "org/latex-previews/"))
    (setq org-format-latex-options
          (plist-put org-format-latex-options :scale (/ 4 3.0)))

    ;; Appearance - Export
    (push '("" "listings" nil) org-latex-packages-alist)
    :delight org-cdlatex-mode)

  (use-package org-agenda
    :bind
    ("C-c o a" . org-agenda)
    :config
    (use-package counsel
      :bind
      (:map org-agenda-mode-map
       ([remap org-agenda-set-tags] . counsel-org-tag-agenda)))

    (setq org-agenda-time-leading-zero t))

  (use-package org-capture
    :bind
    (("C-c o c" . org-capture)
     ("C-c j s" . org-capture-goto-last-stored)))

  (use-package org-clock
    :bind
    (("C-c j c" . org-clock-goto)
     ("C-c o o" . org-clock-out)
     ("C-c o x" . org-clock-cancel))
    :config
    (declare-function org-clock-load "org-clock")

    (setq org-clock-persist 'clock)

    (org-clock-load))

  (use-package org-src
    :bind
    (:map org-src-mode-map
     ("C-c o '" . org-edit-src-exit)
     ("C-c o k" . org-edit-src-abort))
    :preface
    (define-advice org-src--construct-edit-buffer-name
        (:override (org-buffer-name _lang) koek-org/construct-buffer-name)
      ;; Mirror helpful buffer names
      (format "*org-src: %s*" org-buffer-name))

    (defconst koek-org/excluded-checkers
      '((emacs-lisp-mode . (emacs-lisp-checkdoc)))
      "Alist of excluded checker pairs.
  Excluded checker pair is a cons. Its car is a major mode symbol,
  its cdr is a list of checker symbols.")

    (defun koek-org/disable-excluded-checkers ()
      "Disable excluded checkers for current."
      (dolist (checker (alist-get major-mode koek-org/excluded-checkers))
        (unless (memq checker flycheck-disabled-checkers)
          (push checker flycheck-disabled-checkers))))
    :config
    ;; Resolve keybinding conflict with cider
    (unbind-key "C-c '" org-src-mode-map)
    (unbind-key "C-c C-k" org-src-mode-map)

    (push '("js" . js2) org-src-lang-modes)
    (add-hook 'org-src-mode-hook #'koek-org/disable-excluded-checkers)
    :delight)

  (use-package ob-core
    :defer t
    :config
    (declare-function org-babel-get-src-block-info "ob-core")

    (defun koek-org/get-src-block-var-value (var-name)
      "Return value of variable VAR-NAME in current source block.
  VAR-NAME is a string, the variable name."
      (thread-last (org-babel-get-src-block-info 'light)
        (nth 2)                           ; Header arguments
        (seq-filter (pcase-lambda (`(,type))
                      (eq type :var)))
        (mapcar (pcase-lambda (`(,_type . ,value))
                  ;; Variable value could include "=" (e.g. :var
                  ;; foo="bar=baz")
                  (let ((pos (string-match-p "=" value)))
                    (cons (substring value 0 pos) (substring value (1+ pos))))))
        (seq-filter (pcase-lambda (`(,name))
                      (string= name var-name)))
        cdar))

    ;; Evaluate code blocks in buffer after confirmation
    (let ((whitelist ()))
      (setq org-confirm-babel-evaluate
            (lambda (_language _body)
              ;; A reference to a buffer is a good id but would storing
              ;; a reference prevent the buffer from being garbage
              ;; collected?
              (let ((id (or (buffer-file-name) (buffer-name))))
                (unless (assoc id whitelist)
                  (push (cons id
                              (yes-or-no-p
                               (format "Evaluate code blocks in %s on your system this session? "
                                       id)))
                        whitelist))
                (not (cdr (assoc id whitelist))))))))

  (use-package ob-clojure
    :defer t
    :config
    (setq org-babel-clojure-backend 'cider))

  (use-package ol
    :defer t
    :config
    (setq org-link-keep-stored-after-insertion t))

  (use-package ox
    :defer t
    :config
    (setq org-export-headline-levels 4)
    (setq org-export-with-date nil)
    (setq org-export-with-toc 3))

  (use-package ox-html
    :defer t
    :config
    (setq org-html-doctype "html5")
    (setq org-html-html5-fancy t))

  (use-package ox-icalendar
    :defer t
    :config
    (setq org-icalendar-timezone "Europe/Brussels"))

  (use-package ox-latex
    :defer t
    :config
    (setq org-latex-pdf-process '("latexmk -pdf %f"))
    (setq org-latex-listings t)

    ;; Setup hyperref
    (let ((options
           (let ((normalized
                  (replace-regexp-in-string (rx (any " \n")) ""
                                            org-latex-hyperref-template)))
             (string-match
              (rx "{" (submatch-n 1 (one-or-more (any letter "={}%,"))) "}")
              normalized)
             (split-string (match-string 1 normalized) ","))))
      (setq org-latex-hyperref-template
            (concat "\\hypersetup{\n "
                    (string-join (append options '("hidelinks")) ",\n ")
                    "\n}\n"))))

  (koek-pkg/ensure 'htmlize)              ; Optional dependency
#+END_SRC

*** org-caldav - Sync calendars
[[https://github.com/dengste/org-caldav][org-caldav (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package org-caldav
    :ensure t
    :bind
    ("C-c o s" . org-caldav-sync))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ((rx ".py" string-end) . python-mode)
    :preface
    (declare-function python-flymake "python")

    (defun koek-py/disable-checker ()
      "Disable Python checker for current."
      (remove-hook 'flymake-diagnostic-functions #'python-flymake 'local))
    :config
    (use-package devdocs-lookup
      :bind
      (:map python-mode-map
       ("C-c d d" . devdocs-lookup-python~3.7)
       ("C-c d C-i" . devdocs-lookup-scikit_image)
       ("C-c d C-l" . devdocs-lookup-scikit_learn)
       ("C-c d C-m" . devdocs-lookup-matplotlib~3.1)
       ("C-c d C-n" . devdocs-lookup-numpy~1.17)
       ("C-c d C-p" . devdocs-lookup-pandas~0.25)
       ("C-c d C-s" . devdocs-lookup-statsmodels)))

    (add-hook 'python-mode-hook #'koek-py/disable-checker)
    :delight (python-mode "Py" :major))
#+END_SRC

*** pipenv - Consume packages
[[https://github.com/pwalsh/pipenv.el][pipenv (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package pipenv
    :ensure t
    :hook (python-mode . pipenv-mode)
    :delight)
#+END_SRC

** Scheme
#+BEGIN_SRC emacs-lisp
  (use-package scheme
    :mode ((rx ".scm" string-end) . scheme-mode)
    :delight
    (scheme-mode
     (:eval
      (if geiser-impl--implementation
          (capitalize (symbol-name geiser-impl--implementation))
        "Scm"))
     :major))
#+END_SRC

*** geiser - Interact with process
[[https://github.com/jaor/geiser][geiser (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :ensure t
    :after scheme)

  (use-package geiser-autodoc
    :defer t
    :delight)

  (use-package geiser-impl
    :defer t
    :config
    (setq geiser-default-implementation 'guile))

  (use-package geiser-mode
    :defer t
    :delight)

  (use-package geiser-repl
    :defer t
    :config
    (setq geiser-repl-query-on-exit-p t))
#+END_SRC

** SQL
#+BEGIN_SRC emacs-lisp
  (use-package sql
    :mode ((rx ".sql" string-end) . sql-mode)
    :preface
    ;; When SQL dialect is setup, whitespace-mode faces are overridden
    (define-advice sql-mode (:around (f) koek-sql/defer-whitespace-mode)
      (let ((prog-mode-hook               ; Dynamic variable
             (remq 'whitespace-mode prog-mode-hook)))
        (funcall f)))

    (define-advice sql-highlight-product
        (:around (f) koek-sql/re-enable-whitespace-mode)
      (whitespace-mode 0)
      (funcall f)
      (whitespace-mode))

    ;; When SQL dialect is setup, mode-name is overridden (i.e. delight
    ;; is undone)
    (define-advice sql-highlight-product (:after () koek-sql/update-mode-name)
      (setq mode-name
            '(:eval
              ;; When mode-name is evaluated outside mode line,
              ;; inhibit-mode-name-delight is truthy
              (if (or inhibit-mode-name-delight (eq sql-product 'ansi))
                  "SQL"
                (sql-get-product-feature sql-product :name)))))
    :config
    (use-package devdocs-lookup
      :bind
      (:map sql-mode-map
       ("C-c d C-p" . devdocs-lookup-postgresql~11)))

    (setq sql-product 'postgres))
#+END_SRC

*** sql-indent - Indent code
#+BEGIN_SRC emacs-lisp
  (use-package sql-indent
    :ensure t
    :hook (sql-mode . sqlind-minor-mode)
    :delight sqlind-minor-mode)
#+END_SRC

** TeX
TeX configuration is a placeholder. [[*Org][Org]] optionally requires CDLaTeX
which requires AUCTeX.

[[https://www.gnu.org/software/auctex/][auctex]]

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex
    :mode ((rx ".tex" string-end) . TeX-tex-mode))
#+END_SRC

*** cdlatex - Assist with writing LaTeX
[[https://github.com/cdominik/cdlatex][cdlatex (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :ensure t
    :hook (LaTeX-mode . cdlatex-mode)
    :delight)
#+END_SRC

** Text
#+BEGIN_SRC emacs-lisp
  (use-package text-mode
    :mode (rx (or ".txt" "/README" "/LICENSE") string-end)
    :delight (text-mode "Txt" :major))
#+END_SRC

** Conf
Conf mode's mode declaration requires precedence over Text mode's.
Configure Conf mode after Text mode.

#+BEGIN_SRC emacs-lisp
  (use-package conf-mode
    :mode (rx "cross.txt" string-end)
    :preface
    (defconst koek-conf/mode-names
      '((conf-colon-mode . "Conf:")
        (conf-desktop-mode . "Desktop")
        (conf-javaprop-mode . "Properties")
        (conf-ppd-mode . "PPD")
        (conf-space-mode . "Conf·")
        (conf-toml-mode . "TOML")
        (conf-unix-mode . "Unix")
        (conf-windows-mode . "INI")
        (conf-xdefaults-mode . "Xdefaults"))
      "Alist of Conf mode symbol to Conf mode name pairs.")

    (define-advice conf-mode-initialize
        (:after (&rest _args) koek-conf/update-mode-name)
      (setq mode-name
            '(:eval
              (or (and (not inhibit-mode-name-delight)
                       (alist-get major-mode koek-conf/mode-names))
                  "Conf")))))
#+END_SRC

** Wolfram Language
[[https://github.com/kawabata/wolfram-mode][wolfram-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package wolfram-mode
    :ensure t
    :mode (rx ".wl" string-end)
    :delight (wolfram-mode "WL" :major))
#+END_SRC

** YASnippet
For the minor mode, see [[*yasnippet - Snippets][yasnippet - Snippets]].

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :mode ("/snippets/" . snippet-mode))
#+END_SRC

* Appearance
Maximize frames.

#+BEGIN_SRC emacs-lisp
  (push '(fullscreen . maximized) default-frame-alist)
#+END_SRC

Show file name in title bar.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '((:eval
           ;; Resolve conflict between `file-truename' and
           ;; `query-replace', see
           ;; https://debbugs.gnu.org/cgi/bugreport.cgi?bug=33697
           (save-match-data
             (let ((file-name (buffer-file-name)))
               (cond
                ((and (projectile-project-p) file-name)
                 (format "~%s/%s"
                         (projectile-project-name)
                         (file-relative-name (file-truename file-name)
                                             (projectile-project-root))))
                (file-name
                 (abbreviate-file-name file-name))
                (t
                 "%b")))))
          " - Emacs"))
#+END_SRC

Disable menu bar, tool bar and scroll bars.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
#+END_SRC

Load [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow]] theme.

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t
    :preface
    (declare-function color-rgb-to-hex "color")

    (defconst koek-thm/theme-specs
      '((:theme sanityinc-tomorrow-blue     :name "Blue"     :palette blue     :dark t)
        (:theme sanityinc-tomorrow-bright   :name "Bright"   :palette bright   :dark t)
        (:theme sanityinc-tomorrow-day      :name "Day"      :palette day      :dark nil)
        (:theme sanityinc-tomorrow-eighties :name "Eighties" :palette eighties :dark t)
        (:theme sanityinc-tomorrow-night    :name "Night"    :palette night    :dark t))
      "List of theme specifications.
  A theme specification is a plist with keys :theme, :name,
  :palette and :dark.  :theme is a symbol, a Tomorrow theme
  variant.  :name is a string, the theme name.  :palette is a
  symbol, the theme color palette, see
  `color-theme-sanityinc-tomorrow-colors'.  :dark is a symbol,
  whether the theme is dark.")

    (defconst koek-thm/default-theme 'sanityinc-tomorrow-eighties
      "Default theme.")

    (when (executable-find "xprop")
      (defun koek-thm/set-frame-theme-variant (frame)
        "Set frame theme variant of FRAME.
  When window theme is a dark theme, the variant is set to dark,
  else, it's set to nothing."
        (let* ((spec (seq-find (lambda (spec)
                                 (eq (plist-get spec :theme)
                                     (car custom-enabled-themes)))
                               koek-thm/theme-specs))
               (variant (or (and (plist-get spec :dark) "dark") "")))
          (call-process "xprop" nil nil nil
                        "-id" (frame-parameter frame 'outer-window-id)
                        "-f" "_GTK_THEME_VARIANT" "8u"
                        "-set" "_GTK_THEME_VARIANT" variant)))

      (add-hook 'after-make-frame-functions #'koek-thm/set-frame-theme-variant))

    (defun koek-thm/mix (color1 color2 &optional ratio)
      "Mix COLOR1 with COLOR2 according to RATIO.
  COLOR1 and COLOR2 are strings, a color name or an RGB triplet,
  see `color-name-to-rgb'.  Optional RATIO is a float from zero to
  one and defaults to one half.  Zero means mix zero units of
  COLOR1 with one unit of COLOR2, one means mix one unit of COLOR1
  with zero units of COLOR2."
      (unless ratio
        (setq ratio 0.5))
      (let ((ratio´ (- 1 ratio)))
        (apply #'color-rgb-to-hex
               (seq-mapn (lambda (component component´)
                           (+ (* component ratio) (* component´ ratio´)))
                         (color-name-to-rgb color1) (color-name-to-rgb color2)))))

    (defun koek-thm/enable (theme-spec)
      "Enable theme THEME-SPEC.
  THEME-SPEC is a theme specification, see
  `koek-thm/tmrw-theme-specs'."
      (interactive
       (list
        (let ((candidates
               (mapcar (lambda (spec)
                         (cons (format "%s (%s)"
                                       (plist-get spec :name)
                                       (or (and (plist-get spec :dark) "dark")
                                           "light"))
                               spec))
                       koek-thm/theme-specs)))
          (cdr (assoc (completing-read "Theme: " candidates nil t) candidates)))))
      ;; Set window theme
      (mapc #'disable-theme custom-enabled-themes)
      (load-theme (plist-get theme-spec :theme) 'no-confirm)
      (let* ((palette
              (let* ((theme (alist-get (plist-get theme-spec :palette)
                                       color-theme-sanityinc-tomorrow-colors))
                     (personal
                      (map-let (foreground background) theme
                        `((alt-bg . ,(koek-thm/mix background foreground 0.98))
                          (lc-fg  . ,(koek-thm/mix foreground background))))))
                (append personal theme)))
             (specs
              (map-let
                  (foreground background current-line selection red alt-bg lc-fg)
                  palette
                `(;; Default
                  (show-paren-match    :foreground ,foreground :background ,selection)
                  (show-paren-mismatch :foreground ,foreground :background unspecified
                                       :underline (:style wave :color ,red))
                  (header-line         :background unspecified)
                  (fringe              :background ,alt-bg)
                  (mode-line           :background ,current-line
                                       :underline ,selection :overline ,selection
                                       :box unspecified :weight unspecified)
                  (mode-line-inactive  :background ,alt-bg
                                       ;; Moody doesn't see inherited
                                       ;; attributes
                                       :underline ,selection :overline ,selection
                                       :weight unspecified)
                  ;; avy
                  (avy-lead-face   :weight normal :slant normal)
                  (avy-lead-face-0 :inherit avy-lead-face)
                  (avy-lead-face-1 :inherit avy-lead-face)
                  (avy-lead-face-2 :inherit avy-lead-face)
                  ;; paren-face
                  (parenthesis :foreground ,lc-fg)
                  ;; whitespace
                  (whitespace-trailing :foreground unspecified :background ,selection)
                  (whitespace-empty    :foreground unspecified :background ,selection)
                  (whitespace-line     :foreground unspecified :background ,selection)
                  ;; ace-window
                  (aw-leading-char-face :background ,background
                                        :weight bold :slant normal)
                  (aw-background-face   :background ,background)
                  ;; eyebrowse
                  (eyebrowse-mode-line-active :foreground ,foreground)))))
        ;; Adding attributes to a face before it's defined, fails. Add
        ;; attributes to user theme.
        (apply #'custom-set-faces
               (mapcar (pcase-lambda (`(,name . ,attrs))
                         `(,name ((t . ,attrs))))
                       specs)))

      ;; Set frame theme
      (when (fboundp 'koek-thm/set-frame-theme-variant)
        (mapc #'koek-thm/set-frame-theme-variant (frame-list))))
    :config
    (when-let ((spec (seq-find (lambda (spec)
                                 (eq (plist-get spec :theme)
                                     koek-thm/default-theme))
                               koek-thm/theme-specs)))
      (koek-thm/enable spec)))
#+END_SRC

Set default font. Try [[https://www.fsd.it/shop/fonts/pragmatapro/][PragmataPro Mono]], then [[https://adobe-fonts.github.io/source-code-pro/][Source Code Pro]].

#+BEGIN_SRC emacs-lisp
  (when-let
      ((spec (seq-find (lambda (spec)
                         (member (plist-get spec :family) (font-family-list)))
                       '((:family "PragmataPro Mono" :size 15)
                         (:family "Source Code Pro"  :size 15)))))
    (set-frame-font (apply #'font-spec spec) nil t))
#+END_SRC

Disable blink cursor mode, instead, enable highlight line mode.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (global-hl-line-mode)
#+END_SRC

Set mode line. Style it with [[https://github.com/tarsius/moody][moody]].

#+BEGIN_SRC emacs-lisp
  (use-package moody
    :ensure t
    :preface
    (declare-function eyebrowse--get "eyebrowse")
    (declare-function flymake--backend-state-diags "flymake")
    (declare-function flymake--lookup-type-property "flymake")
    (declare-function flymake-disabled-backends "flymake")
    (declare-function flymake-reporting-backends "flymake")
    (declare-function flymake-running-backends "flymake")

    (defconst koek-ml/separator (make-string 3 ?\s)
      "Mode line group separator.")

    (defconst koek-ml/large-separator
      (make-string (* (length koek-ml/separator) 5) ?\s)
      "Mode line left right separator.")

    (defun koek-ml/mru-window-p ()
      "Return whether selected window is most recently used window."
      (eq (selected-window) (get-mru-window nil 'dedicated)))

    (defconst koek-ml/dummies '((eldoc-mode-line-string nil))
      "Dummies mode line construct.
  A dummy prevents a package from modifying the mode line.")

    (defconst koek-ml/eldoc
      '(eldoc-mode-line-string ("" eldoc-mode-line-string koek-ml/separator))
      "Eldoc mode line construct.")

    (defvar-local koek-ml/variant nil
      "Ediff variant.")

    (defconst koek-ml/ediff
      '(:eval
        (when koek-ml/variant
          `(,(moody-ribbon
              (concat (plist-get koek-ml/variant :label)
                      (when-let ((state (plist-get koek-ml/variant :state)))
                        (concat " " state)))
              nil 'up)
            koek-ml/separator)))
      "Ediff mode line construct.")

    (defconst koek-ml/depth
      '(:eval
        (let ((depth (- (recursion-depth) (minibuffer-depth))))
          (when (and (> depth 0) (koek-ml/mru-window-p))
            `(,(moody-ribbon (format "[%d]" depth) nil 'up)
              koek-ml/separator))))
      "Recursive edit depth mode line construct.")

    (defconst koek-ml/roman-numerals
      '((9 . "IX")
        (5 . "V")
        (4 . "IV")
        (1 . "I"))
      "Alist of sorted Arabic numeral to Roman numeral pairs.")

    (defun koek-ml/arabic-to-roman (n &optional roman-numerals)
      "Convert Arabic number N to a Roman number.
  N is an integer greater than zero.  ROMAN-NUMERALS is used
  internally."
      (unless roman-numerals
        (setq roman-numerals koek-ml/roman-numerals))
      (when (> n 0)
        (pcase-let ((`(,arabic . ,roman) (car roman-numerals)))
          (if (>= n arabic)
              (concat roman (koek-ml/arabic-to-roman (- n arabic) roman-numerals))
            (koek-ml/arabic-to-roman n (cdr roman-numerals))))))

    (defun koek-ml/get-workspaces ()
      "Return workspaces of selected frame."
      (mapcar (lambda (workspace)
                (let ((id (nth 0 workspace))
                      (name (let ((name (nth 2 workspace)))
                              (unless (string= name "")
                                name))))
                  (list :id id
                        :label (concat (koek-ml/arabic-to-roman id)
                                       (when name
                                         (concat ":" name))))))
              (eyebrowse--get 'window-configs)))

    (defun koek-ml/get-selected-workspace-id ()
      "Return selected workspace id of selected frame."
      (eyebrowse--get 'current-slot))

    (defconst koek-ml/eyebrowse
      '(:eval
        (when (and (bound-and-true-p eyebrowse-mode) (koek-ml/mru-window-p))
          (let ((workspaces (koek-ml/get-workspaces))
                (selected-id (koek-ml/get-selected-workspace-id)))
            (when (or (> (length workspaces) 1) (not (= selected-id 1)))
              `(,(moody-ribbon
                  (mapconcat
                   (lambda (workspace)
                     (let ((face (if (= (plist-get workspace :id)
                                        selected-id)
                                     'eyebrowse-mode-line-active
                                   'eyebrowse-mode-line-inactive)))
                       (propertize (plist-get workspace :label) 'face face)))
                   workspaces " ")
                  nil 'up)
                koek-ml/separator)))))
      "Eyebrowse mode line construct.")

    (defconst koek-ml/id
      '(:eval
        (moody-tab (concat (when (projectile-project-p)
                             (concat (projectile-project-name) "/"))
                           (propertize (buffer-name)
                                       'face 'mode-line-buffer-id))))
      "Id mode line construct.")

    (defconst koek-ml/state '(" " "%*%+")
      "State mode line construct.")

    (defconst koek-ml/position
      '(:eval
        `("" koek-ml/large-separator
          ,(when (buffer-narrowed-p)
             (list (moody-ribbon "Narrowed" nil 'up) " "))
          "%p" " " "%l,%c"))
      "Position mode line construct.")

    (defconst koek-ml/input
      '(:eval
        (when (and current-input-method (koek-ml/mru-window-p))
          `("" koek-ml/separator
            ,(moody-ribbon current-input-method-title nil 'up))))
      "Input mode line construct.")

    (defconst koek-ml/checker-names
      '((eglot-flymake-backend . "LSP")
        (emacs-lisp . "El")
        (emacs-lisp-checkdoc . "Checkdoc")
        (erlang . "Erlc")
        (html-tidy . "Tidy")
        (javascript-jslint . "JSLint"))
      "Alist of checker symbol to checker name pairs.")

    (defun koek-ml/state-to-description (state)
      "Convert checker state STATE to a description.
  STATE is a symbol, a flycheck or flymake state."
      (let ((words (split-string (symbol-name state) "-")))
        (string-join (cons (capitalize (car words)) (cdr words)) " ")))

    (defconst koek-ml/flycheck-diag-specs
      '((:type error   :face compilation-error)
        (:type warning :face compilation-warning))
      "List of flycheck diagnosis specifications.
  A flycheck diagnosis specification is a plist with keys :type and
  :face.  :type is a symbol, a type of error.  :face is a symbol,
  the face for showing the number of errors of type :type in the
  mode line.")

    (defconst koek-ml/flycheck
      '(:eval
        (when (and (bound-and-true-p flycheck-mode) (koek-ml/mru-window-p))
          `("" koek-ml/separator
            ,(when-let ((name (alist-get (flycheck-get-checker-for-buffer)
                                         koek-ml/checker-names)))
               (concat name " "))
            ,(pcase flycheck-last-status-change
               (`running
                "- -")
               (`finished
                (let ((n-diags (flycheck-count-errors flycheck-current-errors)))
                  (mapconcat
                   (lambda (spec)
                     (propertize (number-to-string
                                  (alist-get (plist-get spec :type) n-diags 0))
                                 'face (plist-get spec :face)))
                   koek-ml/flycheck-diag-specs " ")))
               (`,state
                (koek-ml/state-to-description state))))))
      "Flycheck mode line construct.")

    (defun koek-ml/get-flymake-state ()
      "Return flymake state.
  State is the symbol running (some checkers running),
  finished (all checkers finished running), all-disabled (all
  compatible checkers disabled) or no-checker (no compatible
  checkers)."
      (let* ((enabled (flymake-running-backends))
             (finished (flymake-reporting-backends))
             (running (seq-filter (lambda (checker)
                                    (not (memq checker finished)))
                                  enabled))
             (disabled (flymake-disabled-backends)))
        (cond
         (running
          'running)
         (finished
          'finished)
         (disabled
          'all-disabled)
         (t
          'no-checker))))

    (defun koek-ml/get-flymake-n-diags ()
      "Return number of diagnosis per type of error."
      (thread-last (hash-table-values flymake--backend-state)
        (seq-mapcat #'flymake--backend-state-diags)
        (seq-group-by (lambda (diag)
                        (flymake--lookup-type-property (flymake--diag-type diag)
                                                       'flymake-category)))
        (mapcar (pcase-lambda (`(,cat . ,diags))
                  (cons cat (length diags))))))

    (defconst koek-ml/flymake
      '(:eval
        ;; Why is flymake-mode unbound after load?
        (when (and (bound-and-true-p flymake-mode) (koek-ml/mru-window-p))
          `("" koek-ml/separator
            ,(when-let ((name
                         ;; Assume only one checker enabled
                         (alist-get (car (flymake-running-backends))
                                    koek-ml/checker-names)))
               (concat name " "))
            ,(pcase (koek-ml/get-flymake-state)
               (`running
                "- -")
               (`finished
                (let ((n-diags (koek-ml/get-flymake-n-diags)))
                  (mapconcat
                   (lambda (cat)
                     (propertize
                      (number-to-string (alist-get cat n-diags 0))
                      'face (flymake--lookup-type-property cat 'mode-line-face)))
                   '(flymake-error flymake-warning) " ")))
               (`,state
                (koek-ml/state-to-description state))))))
      "Flymake mode line construct.")

    (defconst koek-ml/vc
      '(:eval
        (when (and (bound-and-true-p vc-mode) (koek-ml/mru-window-p))
          (let ((state (string-trim (substring-no-properties vc-mode))))
            ;; For format, see `vc-default-mode-line-string'
            (string-match
             (rx (submatch-n 1 (one-or-more (not (any "-:@!?")))) (any "-:@!?")
                 (zero-or-one (not (any ":")) ":")
                 (submatch-n 2 (one-or-more not-newline)))
             state)
            `("" koek-ml/separator
              ,(format "%s %s" (match-string 1 state) (match-string 2 state))))))
      "Version control mode line construct.")

    (defconst koek-ml/task
      '(:eval
        (when (and (org-clock-is-active) (koek-ml/mru-window-p))
          `("" koek-ml/separator
            ,(org-duration-from-minutes (org-clock-get-clocked-time)))))
      "Task mode line construct.")

    (defconst koek-ml/modes
      '("" koek-ml/separator "(" mode-name mode-line-process minor-mode-alist ")")
      "Modes mode line construct.")

    ;; ediff
    (defconst koek-ml/diff
      '(:eval
        `("" koek-ml/large-separator
          ,(let ((diff-n (1+ ediff-current-difference))
                 (n-diffs ediff-number-of-differences))
             (cond
              ((< diff-n 1)
               (format "Start -/%d" n-diffs))
              ((> diff-n n-diffs)
               (format "End -/%d" n-diffs))
              (t
               (format "%d/%d" diff-n n-diffs))))))
      "Ediff diff mode line construct.")

    (defconst koek-ml/ediff-buffer-specs
      '((:type A   :buffer ediff-buffer-A)
        (:type B   :buffer ediff-buffer-B)
        (:type C   :buffer ediff-buffer-C)
        (:type Anc :buffer ediff-ancestor-buffer))
      "List of ediff buffer specifications.
  An ediff buffer specification is a plist with keys :type and
  :buffer.  :type is a symbol, a type of buffer.  :buffer is a
  symbol, the variable name which stores the buffer of type
  :type.")

    (defun koek-ml/get-variants ()
      "Return variants of ediff session.
  Must be called from control buffer."
      (seq-reduce (lambda (variants spec)
                    (let ((buffer (symbol-value (plist-get spec :buffer))))
                      (when (buffer-live-p buffer)
                        (let ((type (plist-get spec :type)))
                          (push (list :type type
                                      :buffer buffer
                                      :label (symbol-name type))
                                variants))))
                    variants)
                  koek-ml/ediff-buffer-specs ()))

    (defun koek-ml/get-variant-state (variant)
      "Return state of variant VARIANT.
  Must be called from control buffer."
      (when (ediff-valid-difference-p)
        (let ((type (plist-get variant :type)))
          (cond
           ((eq type 'C)
            (concat
             (ediff-get-state-of-diff ediff-current-difference type)
             (when-let ((merge (ediff-get-state-of-merge ediff-current-difference)))
               (concat " " merge))
             (when (ediff-get-state-of-ancestor ediff-current-difference)
               " AncEmpty")))
           ((eq type 'Anc)
            (when-let ((merge (ediff-get-state-of-merge ediff-current-difference)))
              (cond
               ((string= merge "prefer-A")
                "=diff(B)")
               ((string= merge "prefer-B")
                "=diff(A)"))))
           (t
            (ediff-get-state-of-diff ediff-current-difference type))))))

    (define-advice ediff-refresh-mode-lines
        (:override () koek-ml/update-variants)
      (setq mode-line-format
            `(,@koek-ml/dummies " "
              koek-ml/eldoc koek-ml/depth koek-ml/eyebrowse koek-ml/id
              koek-ml/diff koek-ml/task koek-ml/modes))
      (force-mode-line-update)
      (dolist (variant (koek-ml/get-variants))
        (let ((state (koek-ml/get-variant-state variant)))
          (with-current-buffer (plist-get variant :buffer)
            (setq koek-ml/variant
                  (list :label (plist-get variant :label) :state state))
            (force-mode-line-update)))))

    (defun koek-ml/cleanup-variants ()
      "Cleanup variants."
      (save-current-buffer
        (dolist (variant (koek-ml/get-variants))
          (set-buffer (plist-get variant :buffer))
          (kill-local-variable 'koek-ml/variant)
          (force-mode-line-update))))

    (add-hook 'ediff-cleanup-hook #'koek-ml/cleanup-variants)
    :config
    (setq x-underline-at-descent-line t)
    (setq moody-mode-line-height 24)
    (setq-default mode-line-format
                  `(,@koek-ml/dummies " "
                    koek-ml/eldoc koek-ml/depth koek-ml/ediff koek-ml/eyebrowse
                    koek-ml/id koek-ml/state
                    koek-ml/position koek-ml/input koek-ml/flycheck
                    koek-ml/flymake koek-ml/vc koek-ml/task koek-ml/modes)))
#+END_SRC

* Footer
#+BEGIN_SRC emacs-lisp
  ;;; 50-general.el ends here
#+END_SRC

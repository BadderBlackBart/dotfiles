#+TITLE: General

* Header
Enable lexical binding. When visiting the tangled file, enable read
only mode.

#+BEGIN_SRC emacs-lisp
  ;;; 50-general.el --- General configuration -*- lexical-binding: t; buffer-read-only: t; -*-

  ;;; Commentary:

  ;; General configuration, part of Koekelas' Emacs configuration.

  ;;; Code:
#+END_SRC

Require libraries.

#+BEGIN_SRC emacs-lisp
  (require 'map)
  (require 'subr-x)
#+END_SRC

Declare variables and functions setup by [[file:init.el][init.el]].

#+BEGIN_SRC emacs-lisp
  (defvar no-littering-etc-directory)
  (defvar no-littering-var-directory)
  (declare-function no-littering-expand-var-file-name "no-littering")
#+END_SRC

* Files

** dired - File manager
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :bind
    ("C-c f f" . dired)
    :config
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq dired-dwim-target t)
    ;; For switches supported by ls-lisp, see
    ;; `ls-lisp--insert-directory'
    (setq dired-listing-switches "-lah"))
#+END_SRC

** Trash
Move deleted files to trash.

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

** projectile - Projects
[[https://github.com/bbatsov/projectile][projectile (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-c p") projectile-command-map)

    (setq projectile-completion-system 'ivy)
    (projectile-mode)
    :delight)
#+END_SRC

** magit - Git
[[https://github.com/magit/magit][magit (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer t)

  (use-package magit-status
    :bind
    ("C-c f g" . magit-status))

  (use-package git-commit
    :defer t
    :preface
    (defun koek-git/check-spelling (force)
      "Check spelling of commit message.
  When FORCE is truthy, continue commit unconditionally."
      (let* ((ispell-skip-region-alist    ; Dynamic variable
              (cons `(,(rx line-start "#") forward-line) ; Single line comment
                    ispell-skip-region-alist))
             (tick (buffer-chars-modified-tick))
             (result (ispell-buffer)))
        (cond
         (force t)
         (result ; When spell check was completed, result is truthy
          ;; When nothing was corrected, character tick counter didn't
          ;; change
          (or (= (buffer-chars-modified-tick) tick)
              (y-or-n-p "Spelling checked.  Commit? "))))))
    :config
    (add-hook 'git-commit-finish-query-functions #'koek-git/check-spelling))
#+END_SRC

** ediff - Diff viewer
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :bind
    (("C-c f d" . ediff-files)
     ("C-c f b" . ediff-current-file)))

  (use-package ediff-init
    :defer t
    :preface
    (declare-function outline-show-all "outline")

    (defun koek-diff/unfold-outline ()
      "Unfold outline in outline and derived modes."
      (when (derived-mode-p 'outline-mode) ; org is derived from outline
        (outline-show-all)))
    :config
    ;; Restore window layout on quit
    (let (last-layout)
      ;; Store window layout before it's modified. Control buffer
      ;; doesn't exist yet.
      (add-hook 'ediff-before-setup-hook
                (lambda ()
                  (setq last-layout (current-window-configuration))))
      ;; Store window layout in a local hook of control buffer. Current
      ;; is control buffer.
      (add-hook 'ediff-mode-hook
                (lambda ()
                  (let ((layout last-layout))
                    ;; Restore window layout
                    (add-hook 'ediff-quit-hook
                              (lambda ()
                                (set-window-configuration layout))
                              'append 'local)))))

    (add-hook 'ediff-prepare-buffer-hook #'koek-diff/unfold-outline))

  (use-package ediff-wind
    :defer t
    :config
    (declare-function ediff-setup-windows-plain "ediff-wind")

    (setq ediff-grab-mouse nil)
    (setq ediff-window-setup-function #'ediff-setup-windows-plain)
    (setq ediff-split-window-function #'split-window-right))
#+END_SRC

** autorevert - Revert file on external change
#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    :config
    (declare-function global-auto-revert-mode "autorevert")

    (global-auto-revert-mode)
    :delight auto-revert-mode)
#+END_SRC

** recentf - Recent files
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (mapc (apply-partially #'add-to-list 'recentf-exclude)
          (list "/share/emacs/"
                ;; Elements are regexps, ~/ and /home/user/ differ
                (expand-file-name (locate-user-emacs-file "elpa/"))
                no-littering-etc-directory
                no-littering-var-directory))
    (recentf-mode))
#+END_SRC

** saveplace - Restore point on revisit
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :config
    (save-place-mode))
#+END_SRC

** Auto save files
Save auto-save files in =~/.emacs.d/var/auto-save/=.

#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+END_SRC

* Editor

** swiper - isearch replacement
[[https://github.com/abo-abo/swiper][swiper (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind
    (:map swiper-map
     ("C-c j" . swiper-avy)))
#+END_SRC

** avy - Jump to visible position
[[https://github.com/abo-abo/avy][avy (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    (("C-c j j" . avy-goto-char-timer)
     ([remap goto-line] . avy-goto-line))
    :config
    (setq avy-all-windows nil)
    (setq avy-all-windows-alt 'all-frames)
    (setq avy-keys '(?q ?s ?d ?f ?j ?k ?l ?m))
    (setq avy-dispatch-alist nil))
#+END_SRC

*** link-hint - Jump to visible link
[[https://github.com/noctuid/link-hint.el][link-hint (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :ensure t
    :bind
    ("C-c j l" . link-hint-open-link))
#+END_SRC

*** Issues

**** Avy and Prettify Symbols conflict
See [[https://github.com/abo-abo/avy/issues/103][Issue 103 (GitHub)]].

** Jump to recent mark positions
When popping mark, skip consecutive identical marks.

#+BEGIN_SRC emacs-lisp
  (define-advice pop-to-mark-command (:around (f) koek-mark/ensure-move)
    (let ((start (point))
          (n (length mark-ring)))
      ;; Move point to current mark
      (funcall f)
      ;; Move point to previous marks in mark ring
      (while (and (= (point) start) (> n 0))
        (funcall f)
        (setq n (1- n)))))
#+END_SRC

** subword - Recognize words in camel case words
#+BEGIN_SRC emacs-lisp
  (use-package subword
    :hook
    ((prog-mode conf-mode eshell-mode comint-mode cider-repl-mode
      indium-repl-mode)
     . subword-mode)
    :delight)
#+END_SRC

** Word motion commands
Complement word motion commands. Unlike ~forward-to-word~ and
~backward-to-word~, ~koek-mtn/next-word~ and ~koek-mtn/previous-word~
recognize [[*subword - Recognize words in camel case words][subwords]].

#+BEGIN_SRC emacs-lisp
  (defun koek-mtn/next-word (&optional arg)
    "Move point to beginning of next word, repeat ARG times.
  Optional ARG is an integer and defaults to one.  When ARG is
  negative, move point to ending of previous word."
    (interactive "p")
    (unless arg
      (setq arg 1))
    (unless (= arg 0)
      (let ((step (/ arg (abs arg))))
        (when (or (and (> step 0) (looking-at (rx word)))
                  (and (< step 0)
                       (looking-back (rx word) (max (1- (point)) (point-min)))))
          (forward-word step))
        (forward-word (- arg step))
        (when (forward-word step)
          (backward-word step)))))

  (defun koek-mtn/previous-word (&optional arg)
    "Move point to ending of previous word, repeat ARG times.
  Optional ARG is an integer and defaults to one.  When ARG is
  negative, move point to beginning of next word."
    (interactive "p")
    (unless arg
      (setq arg 1))
    (koek-mtn/next-word (- arg)))

  (bind-keys
   ("M-n" . koek-mtn/next-word)
   ("M-p" . koek-mtn/previous-word))
#+END_SRC

** auto-fill - Break long sentences
#+BEGIN_SRC emacs-lisp
  (defconst koek-af/excluded-modes '(snippet-mode)
    "List of major mode symbols, see `koek-af/maybe-enable'.")

  (defun koek-af/maybe-enable ()
    "Enable `auto-fill-mode' conditionally.
  Unless current major mode is member of `koek-af/excluded-modes',
  enable `auto-fill-mode'."
    (unless (memq major-mode koek-af/excluded-modes)
      (auto-fill-mode)))

  (add-hook 'text-mode-hook #'koek-af/maybe-enable)
  (delight 'auto-fill-function nil 'emacs)
#+END_SRC

** smartparens - Pairs & symbolic expressions
[[https://github.com/Fuco1/smartparens][smartparens (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :bind
    (:map smartparens-mode-map
     ("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)
     ("C-M-n" . sp-next-sexp)
     ("C-M-p" . sp-previous-sexp)
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)
     ("C-M-d" . sp-down-sexp)
     ("C-M-u" . sp-up-sexp)
     ("C-S-d" . sp-backward-down-sexp)
     ("C-S-u" . sp-backward-up-sexp)
     ("C-M-t" . sp-transpose-sexp)
     ("C-M-w" . sp-copy-sexp)
     ("C-M-k" . sp-kill-sexp)
     ("C-M-<right>" . sp-forward-slurp-sexp)
     ("C-M-<left>"  . sp-forward-barf-sexp)
     ("C-S-<left>"  . sp-backward-slurp-sexp)
     ("C-S-<right>" . sp-backward-barf-sexp)
     ("C-M-<down>"  . sp-unwrap-sexp))
    :hook
    (((prog-mode conf-mode eshell-mode comint-mode cider-repl-mode
       indium-repl-mode)
      . smartparens-mode)
     (smartparens-mode . show-smartparens-mode))
    :preface
    (declare-function sp--get-context "smartparens")
    (declare-function sp-get-pair "smartparens")
    (declare-function sp-local-pair "smartparens")

    (defun koek-sp/separate-sexp (open-delimiter action _context)
      "Separate just inserted sexp from previous and/or next sexp.
  OPEN-DELIMITER is a string, the delimiter inserted.  ACTION is a
  symbol, the action performed, see `sp-pair'.  _CONTEXT is
  ignored."
      (when (and (eq action 'insert)
                 ;; Outer context, _context is inner context
                 (save-excursion
                   (search-backward open-delimiter)
                   (eq (sp--get-context) 'code)))
        (save-excursion
          (search-backward open-delimiter)
          (unless (looking-back (rx (or (any "#'`,~@([{" blank) line-start))
                                (max (1- (point)) (point-min)))
            (insert " "))
          (search-forward open-delimiter)
          (search-forward (sp-get-pair open-delimiter :close))
          (unless (looking-at (rx (or (any ")]}" blank) line-end)))
            (insert " ")))))

    (defun koek-sp/setup-separate-sexp-handler (mode &rest open-delimiters)
      "Setup separate-sexp handler in MODE for OPEN-DELIMITERS.
  MODE is a major mode symbol.  OPEN-DELIMITERS are one or more
  strings."
      (dolist (open-delimiter open-delimiters)
        (sp-local-pair mode open-delimiter nil
                       :post-handlers '(:add koek-sp/separate-sexp))))

    (defun koek-sp/format-c-block (open-delimiter action _context)
      "Format just inserted multiple line C block.
  OPEN-DELIMITER is a string, the delimiter inserted.  ACTION is a
  symbol, the action performed, see `sp-pair'.  _CONTEXT is
  ignored."
      (when (and (eq action 'insert)
                 (save-excursion
                   (search-backward open-delimiter)
                   (eq (sp--get-context) 'code)))
        (save-excursion
          (insert "\n")
          (indent-according-to-mode))
        (indent-according-to-mode)))

    (defun
        koek-sp/setup-format-c-block-on-return-handler
        (mode &rest open-delimiters)
      "Setup format-c-block handler in MODE for OPEN-DELIMITERS.
  MODE is a major mode symbol.  OPEN-DELIMITERS are one or more
  strings."
      (dolist (open-delimiter open-delimiters)
        (sp-local-pair mode open-delimiter nil
                       ;; For event names, see `single-key-description'
                       :post-handlers '(:add (koek-sp/format-c-block "RET")))))
    :init
    (bind-keys
     ("C-M-{" . beginning-of-defun)
     ("C-M-}" . end-of-defun)
     ("C-S-w" . append-next-kill))
    :config
    (require 'smartparens-config)

    (setq sp-navigate-interactive-always-progress-point t)
    (setq sp-navigate-reindent-after-up ())
    (setq sp-highlight-pair-overlay nil)
    (koek-sp/setup-separate-sexp-handler 'clojure-mode "(" "[" "{" "\"")
    (koek-sp/setup-separate-sexp-handler 'lisp-mode "(" "\"")
    (koek-sp/setup-separate-sexp-handler 'emacs-lisp-mode "(" "[" "\"")
    (koek-sp/setup-separate-sexp-handler 'scheme-mode "(" "\"")
    (koek-sp/setup-format-c-block-on-return-handler 'c-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'c++-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'css-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'java-mode "{")
    (koek-sp/setup-format-c-block-on-return-handler 'js2-mode "{" "[")
    (koek-sp/setup-format-c-block-on-return-handler 'json-mode "{" "[")
    (koek-sp/setup-format-c-block-on-return-handler 'scad-mode "{")
    :delight)
#+END_SRC

** rainbow-delimiters - Show bracket depth
[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :hook
    ((clojure-mode lisp-mode emacs-lisp-mode scheme-mode)
     . rainbow-delimiters-mode))
#+END_SRC

** expand-region - Mark increasingly larger unit
[[https://github.com/magnars/expand-region.el][expand-region (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind
    ("C-S-SPC" . er/expand-region)
    :config
    (setq expand-region-smart-cursor t))
#+END_SRC

** prettify-symbols - Show composed symbols
#+BEGIN_SRC emacs-lisp
  (defun koek-ps/make-baseline-right-left-spec (&rest chars)
    "Return composition specification for CHARS.
  CHARS are two or more characters.  Baseline right of previous
  character is composed with baseline left of next character."
    (seq-reduce (lambda (spec char)
                  (append spec (list '(Br . Bl) char)))
                (cdr chars) (list (car chars))))

  (defconst koek-ps/comp-specs
    (let ((safe
           '(("function" . ?ƒ)
             ("lambda"   . ?λ)))
          (pragmata
           (when (member "PragmataPro Mono" (font-family-list))
             (mapcar
              (pcase-lambda (`(,symbol . ,char))
                (cons symbol
                      ;; Widen char to symbol characters
                      (apply #'koek-ps/make-baseline-right-left-spec
                             (append (make-list (1- (length symbol)) ?\s)
                                     (list char)))))
              '(("[ERROR]"   . ?\uE380) ("[DEBUG]" . ?\uE381)
                ("[INFO]"    . ?\uE382) ("[WARN]"  . ?\uE383)
                ("[WARNING]" . ?\uE384) ("[ERR]"   . ?\uE385)
                ("[FATAL]"   . ?\uE386) ("[TRACE]" . ?\uE387)
                ("[FIXME]"   . ?\uE388) ("[TODO]"  . ?\uE389)
                ("[BUG]"     . ?\uE38A) ("[NOTE]"  . ?\uE38B)
                ("[HACK]"    . ?\uE38C) ("[MARK]"  . ?\uE38D)
                ;; !
                ("!!"  . ?\uE900) ("!="  . ?\uE901) ("!==" . ?\uE902)
                ("!!!" . ?\uE903) ("!≡"  . ?\uE904) ("!≡≡" . ?\uE905)
                ("!>"  . ?\uE906) ("!=<" . ?\uE907)
                ;; #
                ("#("  . ?\uE920) ("#_" . ?\uE921) ("#{" . ?\uE922)
                ("#?"  . ?\uE923) ("#>" . ?\uE924) ("##" . ?\uE925)
                ("#_(" . ?\uE926)
                ;; %
                ("%="  . ?\uE930) ("%>" . ?\uE931) ("%>%" . ?\uE932)
                ("%<%" . ?\uE933)
                ;; &
                ("&%" . ?\uE940) ("&&"  . ?\uE941) ("&*" . ?\uE942)
                ("&+" . ?\uE943) ("&-"  . ?\uE944) ("&/" . ?\uE945)
                ("&=" . ?\uE946) ("&&&" . ?\uE947) ("&>" . ?\uE948)
                ;; $
                ("$>" . ?\uE955)
                ;; *
                ("***" . ?\uE960) ("*=" . ?\uE961) ("*/" . ?\uE962)
                ("*>"  . ?\uE963)
                ;; +
                ("++" . ?\uE970) ("+++" . ?\uE971) ("+=" . ?\uE972)
                ("+>" . ?\uE973) ("++=" . ?\uE974)
                ;; -
                ("--"   . ?\uE980) ("-<"  . ?\uE981) ("-<<" . ?\uE982)
                ("-="   . ?\uE983) ("->"  . ?\uE984) ("->>" . ?\uE985)
                ("---"  . ?\uE986) ("-->" . ?\uE987) ("-+-" . ?\uE988)
                ("-\\/" . ?\uE989) ("-|>" . ?\uE98A) ("-<|" . ?\uE98B)
                ;; .
                (".." . ?\uE990) ("..." . ?\uE991) ("..<" . ?\uE992)
                (".>" . ?\uE993) (".~"  . ?\uE994) (".="  . ?\uE995)
                ;; /
                ("/*"  . ?\uE9A0) ("//"  . ?\uE9A1) ("/>"  . ?\uE9A2)
                ("/="  . ?\uE9A3) ("/==" . ?\uE9A4) ("///" . ?\uE9A5)
                ("/**" . ?\uE9A6)
                ;; :
                (":::" . ?\uE9AF) ("::"  . ?\uE9B0) (":="  . ?\uE9B1)
                (":≡"  . ?\uE9B2) (":>"  . ?\uE9B3) (":=>" . ?\uE9B4)
                (":("  . ?\uE9B5) (":-(" . ?\uE9B6) (":)"  . ?\uE9B7)
                (":-)" . ?\uE9B8) (":/"  . ?\uE9B9) (":\\" . ?\uE9BA)
                (":3"  . ?\uE9BB) (":D"  . ?\uE9BC) (":P"  . ?\uE9BD)
                (":>:" . ?\uE9BE) (":<:" . ?\uE9BF)
                ;; <
                ("<$>"  . ?\uE9C0) ("<*"  . ?\uE9C1) ("<*>"  . ?\uE9C2)
                ("<+>"  . ?\uE9C3) ("<-"  . ?\uE9C4) ("<<"   . ?\uE9C5)
                ("<<<"  . ?\uE9C6) ("<<=" . ?\uE9C7) ("<="   . ?\uE9C8)
                ("<=>"  . ?\uE9C9) ("<>"  . ?\uE9CA) ("<|>"  . ?\uE9CB)
                ("<<-"  . ?\uE9CC) ("<|"  . ?\uE9CD) ("<=<"  . ?\uE9CE)
                ("<~"   . ?\uE9CF) ("<~~" . ?\uE9D0) ("<<~"  . ?\uE9D1)
                ("<$"   . ?\uE9D2) ("<+"  . ?\uE9D3) ("<!>"  . ?\uE9D4)
                ("<@>"  . ?\uE9D5) ("<#>" . ?\uE9D6) ("<%>"  . ?\uE9D7)
                ("<^>"  . ?\uE9D8) ("<&>" . ?\uE9D9) ("<?>"  . ?\uE9DA)
                ("<.>"  . ?\uE9DB) ("</>" . ?\uE9DC) ("<\\>" . ?\uE9DD)
                ("<\">" . ?\uE9DE) ("<:>" . ?\uE9DF) ("<~>"  . ?\uE9E0)
                ("<**>" . ?\uE9E1) ("<<^" . ?\uE9E2) ("<!"   . ?\uE9E3)
                ("<@"   . ?\uE9E4) ("<#"  . ?\uE9E5) ("<%"   . ?\uE9E6)
                ("<^"   . ?\uE9E7) ("<&"  . ?\uE9E8) ("<?"   . ?\uE9E9)
                ("<."   . ?\uE9EA) ("</"  . ?\uE9EB) ("<\\"  . ?\uE9EC)
                ("<\""  . ?\uE9ED) ("<:"  . ?\uE9EE) ("<->"  . ?\uE9EF)
                ("<!--" . ?\uE9F0) ("<--" . ?\uE9F1) ("<~<"  . ?\uE9F2)
                ("<==>" . ?\uE9F3) ("<|-" . ?\uE9F4) ("<||"  . ?\uE9F5)
                ("<<|"  . ?\uE9F6) ("<-<" . ?\uE9F7) ("<-->" . ?\uE9F8)
                ("<<==" . ?\uE9F9) ("<==" . ?\uE9FA)
                ;; =
                ("=<<"  . ?\uEA00) ("=="  . ?\uEA01) ("===" . ?\uEA02)
                ("==>"  . ?\uEA03) ("=>"  . ?\uEA04) ("=~"  . ?\uEA05)
                ("=>>"  . ?\uEA06) ("=/=" . ?\uEA07) ("=~=" . ?\uEA08)
                ("==>>" . ?\uEA09)
                ;; ≡
                ("≡≡" . ?\uEA10) ("≡≡≡" . ?\uEA11) ("≡:≡" . ?\uEA12)
                ;; >
                (">-"  . ?\uEA20) (">="  . ?\uEA21) (">>"  . ?\uEA22)
                (">>-" . ?\uEA23) (">>=" . ?\uEA24) (">>>" . ?\uEA25)
                (">=>" . ?\uEA26) (">>^" . ?\uEA27) (">>|" . ?\uEA28)
                (">!=" . ?\uEA29) (">->" . ?\uEA2A)
                ;; ?
                ("??" . ?\uEA40) ("?~"  . ?\uEA41) ("?=" . ?\uEA42)
                ("?>" . ?\uEA43) ("???" . ?\uEA44) ("?." . ?\uEA45)
                ;; ^
                ("^="  . ?\uEA48) ("^."  . ?\uEA49) ("^?"  . ?\uEA4A)
                ("^.." . ?\uEA4B) ("^<<" . ?\uEA4C) ("^>>" . ?\uEA4D)
                ("^>"  . ?\uEA4E)
                ;; \
                ("\\\\" . ?\uEA50) ("\\>" . ?\uEA51) ("\\/-" . ?\uEA52)
                ;; @
                ("@>" . ?\uEA57)
                ;; |
                ("|="   . ?\uEA60) ("||"  . ?\uEA61) ("|>"   . ?\uEA62)
                ("|||"  . ?\uEA63) ("|+|" . ?\uEA64) ("|->"  . ?\uEA65)
                ("|-->" . ?\uEA66) ("|=>" . ?\uEA67) ("|==>" . ?\uEA68)
                ("|>-"  . ?\uEA69) ("|<<" . ?\uEA6A) ("||>"  . ?\uEA6B)
                ("|>>"  . ?\uEA6C) ("|-"  . ?\uEA6D) ("||-"  . ?\uEA6E)
                ;; ~
                ("~="  . ?\uEA70) ("~>" . ?\uEA71) ("~~>" . ?\uEA72)
                ("~>>" . ?\uEA73)
                ;; [
                ("[[" . ?\uEA80) ("]]" . ?\uEA81)
                ;; "
                ("\">" . ?\uEA90)
                ;; _
                ("_|_" . ?\uEA97))))))
      (append pragmata safe))
    "Alist of pretty symbol to composition specification pairs.")

  (defun koek-ps/make-enable (&rest symbols)
    "Return function to setup and enable function `prettify-symbols-mode'.
  SYMBOLS are one or more pretty symbol pairs and/or pretty
  symbols.

  Pretty symbol pair is a cons. Its car is a string, the symbol to
  replace. Its cdr is a key in `koek-ps/comp-specs', the symbol to
  replace it with. When both symbols are identical, prefer a pretty
  symbol.

  Pretty symbol is a key in `koek-ps/comp-specs'."
    (let ((specs
           (seq-reduce
            (lambda (specs symbol)
              (unless (consp symbol)
                (setq symbol (cons symbol symbol)))
              (pcase-let ((`(,from . ,to) symbol))
                (when-let (spec (cdr (assoc to koek-ps/comp-specs)))
                  (push (cons from spec) specs)))
              specs)
            symbols ())))
      (lambda ()
        (setq prettify-symbols-alist specs)
        (prettify-symbols-mode))))

  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (add-hook 'c-mode-hook
            (koek-ps/make-enable
             "!=" "%=" "&&" "&=" "*=" "++" "+=" "--" "-=" "->" "/=" "<<" "<=" "=="
             ">=" ">>" "^=" "|=" "||"))
  (add-hook 'c++-mode-hook
            (koek-ps/make-enable
             "!=" "%=" "&&" "&=" "*=" "++" "+=" "--" "-=" "->" "/=" "::" "<<" "<="
             "==" ">=" ">>" "^=" "|=" "||"))
  (add-hook 'clojure-mode-hook
            (koek-ps/make-enable '("fn" . "lambda") "->" "->>" "<=" ">="))
  (add-hook 'lisp-mode-hook
            (koek-ps/make-enable "lambda" "<=" ">="))
  (add-hook 'emacs-lisp-mode-hook
            (koek-ps/make-enable "lambda" "<=" ">="))
  (add-hook 'erlang-mode-hook
            (koek-ps/make-enable "->" '("=<" . "<=") ">="))
  (add-hook 'java-mode-hook
            (koek-ps/make-enable
             "!=" "%=" "&&" "&=" "*=" "++" "+=" "--" "-=" "/=" "<<" "<=" "==" ">="
             ">>" ">>>" "^=" "|=" "||"))
  (add-hook 'js2-mode-hook
            (koek-ps/make-enable
             "function" "!!" "!=" "!==" "%=" "&&" "&=" "*=" "++" "+=" "--" "-="
             "..." "/=" "<<" "<=" "==" "===" "=>" ">=" ">>" ">>>" "^=" "|=" "||"))
  (add-hook 'octave-mode-hook
            (koek-ps/make-enable "&&" "<=" "==" ">=" "||" "~="))
  (add-hook 'scad-mode-hook
            (koek-ps/make-enable "!=" "&&" "<=" "==" ">=" "||"))
  (add-hook 'python-mode-hook
            (koek-ps/make-enable "!=" "//" "<<" "<=" "==" ">=" ">>"))
  (add-hook 'scheme-mode-hook
            (koek-ps/make-enable "lambda" "<=" ">="))
  (add-hook 'sql-mode-hook
            (koek-ps/make-enable "::" "<=" "<>" ">="))
#+END_SRC

** Whitespace
Indent with spaces, not tabs.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

End sentences with single space, not double space.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

End files with empty line.

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)

  (defun koek-ws/disable-final-empty-line ()
    "Disable final empty line for current."
    (setq-local require-final-newline nil))

  (add-hook 'snippet-mode-hook #'koek-ws/disable-final-empty-line)
#+END_SRC

** whitespace - Clean & visualize whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :hook ((prog-mode conf-mode) . whitespace-mode)
    :config
    (setq whitespace-action '(auto-cleanup))
    (setq whitespace-style '(face trailing empty lines-tail))
    :delight)
#+END_SRC

*** Issues

**** Modifying display table affects overlays
#+BEGIN_SRC emacs-lisp :tangle no 
  (setq whitespace-style '(space-mark tab-mark newline-mark))
#+END_SRC

** Edit commands
Supercharge edit commands.

#+BEGIN_SRC emacs-lisp
  (bind-key [remap downcase-word] #'downcase-dwim)
  (bind-key [remap upcase-word] #'upcase-dwim)
  (bind-key [remap capitalize-word] #'capitalize-dwim)
#+END_SRC

** Clipboard
Add clipboard to kill ring before killing.

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+END_SRC

** Complete text
When line is indented, press =TAB= to complete text before point.

#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC

** company - Autocomplete code
[[https://github.com/company-mode/company-mode][company (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :bind
    (:map company-mode-map
     ;; Why does [remap indent-for-tab-command] only work in prog-mode?
     ("TAB" . company-indent-or-complete-common)
     :map company-active-map
     ("C-n" . company-select-next)
     ("C-p" . company-select-previous))
    :hook ((prog-mode conf-mode comint-mode cider-repl-mode) . company-mode)
    :preface
    (defun koek-cpny/make-setup-backends (backends)
      "Return function to setup backends for current.
  BACKENDS is a list of backends, see `company-backends'."
      (lambda ()
        (setq-local company-backends backends)))

    ;; Prevent geiser from modifying company-backends
    (define-advice
        geiser-company--setup-company
        (:around (f &rest args) koek-cpny/disable-setup-backends)
      (let ((backends company-backends))
        (apply f args)
        (setq company-backends backends)))
    :config
    (setq company-backends
          '((company-capf company-files :with company-yasnippet)))
    (setq company-idle-delay 1)           ; In seconds
    (setq company-show-numbers t)

    ;; Setup mode specific backends
    (add-hook 'indium-repl-mode-hook
              (koek-cpny/make-setup-backends
               '((company-indium-repl company-files :with company-yasnippet))))
    (let ((setup-geiser-backend
           (koek-cpny/make-setup-backends
            '((geiser-company-backend company-files :with company-yasnippet)))))
      (add-hook 'geiser-mode-hook setup-geiser-backend)
      (add-hook 'geiser-repl-mode-hook setup-geiser-backend))
    (let ((setup-code-backend
           (koek-cpny/make-setup-backends
            '((company-dabbrev-code company-files :with company-yasnippet)))))
      (add-hook 'erlang-mode-hook setup-code-backend)
      (add-hook 'scad-mode-hook setup-code-backend))
    (let ((setup-dabbrev-backend
           (koek-cpny/make-setup-backends
            '((company-dabbrev company-files :with company-yasnippet)))))
      (add-hook 'conf-mode-hook setup-dabbrev-backend))
    :delight)

  (use-package company-dabbrev
    :defer t
    :config
    (setq company-dabbrev-other-buffers t)) ; Same major mode
#+END_SRC

*** company-flx - Match candidates fuzzily
[[https://github.com/PythonNut/company-flx][company-flx (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package company-flx
    :ensure t
    :after company
    :config
    (company-flx-mode))
#+END_SRC

** eglot - Code insight
[[https://github.com/joaotavora/eglot][eglot (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :ensure t
    :bind
    (:map eglot-mode-map
     ("C-c r f" . eglot-code-actions)
     ("C-c r r" . eglot-rename)
     ("C-c C-d" . eglot-help-at-point))
    :hook
    ((c-mode c++-mode mhtml-mode css-mode java-mode js2-mode json-mode
      python-mode)
     . eglot-ensure)
    :config
    ;; Eclipse JDT Language Server lacks an executable. Eglot requires
    ;; the jdtls launcher to be added to the CLASSPATH environment
    ;; variable.
    (when-let
        ((launcher-program-name
          (thread-last '("/usr/share/java/jdtls/plugins/" "c:/bin/jdtls/plugins/")
            (seq-filter #'file-exists-p)
            (seq-mapcat (lambda (file-name)
                          (directory-files file-name 'full
                                           (rx "org.eclipse.equinox.launcher_"
                                               (one-or-more (or alnum punct))
                                               ".jar" line-end))))
            car)))
      (let ((paths (split-string (or (getenv "CLASSPATH") "")
                                 path-separator 'omit-nulls)))
        (unless (member launcher-program-name paths)
          (setenv "CLASSPATH"
                  (string-join (cons launcher-program-name paths)
                               path-separator)))))

    ;; Register additional language servers
    (add-to-list 'eglot-server-programs
                 '(mhtml-mode . ("html-languageserver" "--stdio")))
    (add-to-list 'eglot-server-programs
                 '(css-mode . ("css-languageserver" "--stdio")))
    (add-to-list 'eglot-server-programs
                 '(json-mode . ("json-languageserver" "--stdio"))))

  (use-package flymake
    :bind
    (:map flymake-mode-map
     ("C-c ! n" . flymake-goto-next-error)
     ("C-c ! p" . flymake-goto-prev-error)
     ("C-c ! l" . flymake-show-diagnostics-buffer))
    :config
    (setq flymake-wrap-around nil))

  (use-package flymake-proc
    :defer t
    :config
    (declare-function flymake-proc-legacy-flymake "flymake-proc")

    (remove-hook 'flymake-diagnostic-functions #'flymake-proc-legacy-flymake))
#+END_SRC

*** Setting up ccls
Run =M-x= ~make-symbolic-link~. Create a link to
=compile_commands.json= in the project home directory.

** xref - Jump to definition & references
#+BEGIN_SRC emacs-lisp
  (use-package xref
    :defer t
    :config
    (declare-function xref-find-references "xref")

    (add-to-list 'xref-prompt-for-identifier #'xref-find-references 'append))
#+END_SRC

** abbrev - Abbreviations
#+BEGIN_SRC emacs-lisp
  (use-package abbrev
    :hook ((sql-mode sql-interactive-mode) . abbrev-mode)
    :config
    (declare-function define-abbrev-table "abbrev")
    (declare-function find-library-name "find-func")

    ;; Prime abbrev tables
    (unless (file-exists-p (no-littering-expand-var-file-name "abbrev.el"))
      ;; Upcase SQL keywords
      (let* ((keywords
              (split-string
               (with-temp-buffer
                 (insert-file-contents (find-library-name "sql"))
                 (search-forward "ANSI Reserved keywords")
                 (buffer-substring (re-search-forward
                                    (rx (one-or-more (not (any "\"")))))
                                   (re-search-forward
                                    (rx (one-or-more (not (any ")")))))))
               (rx (any " \n")) 'omit-nulls "\""))
             (abbrevs (mapcar (lambda (keyword)
                                (list keyword (upcase keyword)))
                              keywords)))
        (define-abbrev-table 'sql-mode-abbrev-table abbrevs)
        (define-abbrev-table 'sql-interactive-mode-abbrev-table abbrevs)))

    (setq save-abbrevs 'silently)
    :delight)
#+END_SRC

** yasnippet - Snippets
[[https://github.com/joaotavora/yasnippet][yasnippet (GitHub)]]

For the major mode, see [[*YASnippet][YASnippet]].

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :hook ((text-mode prog-mode conf-mode) . yas-minor-mode)
    :config
    (declare-function koek-org/get-src-block-var-value "50-general")
    (declare-function koek-ys/get-org-name "50-general")
    (declare-function yas-choose-value "yasnippet")
    (declare-function yas-reload-all "yasnippet")

    ;; Snippet odds and ends
    (defun koek-ys/complete-field (candidates)
      "Complete field from CANDIDATES.
  CANDIDATES is an alist of pretty candidate to candidate pairs."
      (cdr (assoc (yas-choose-value (mapcar #'car candidates)) candidates)))

    (defconst koek-ys/ietf-languages
      '(("de-DE" . ("de-de" "ngerman"  "de_DE"))
        ("en-US" . ("en-us" "american" "en_US"))
        ("fr-FR" . ("fr"    "frenchb"  "fr_FR"))
        ("nl-BE" . ("nl"    "dutch"    "nl_BE")))
      "Alist of IETF language pairs.
  IETF language pair is a cons.  Its car is a string, an IETF
  language name.  Its cdr is a list of strings, an Org language
  name, a LaTeX language name and a Hunspell language name.")

    (fset 'koek-ys/get-org-name (apply-partially #'nth 0))
    (fset 'koek-ys/get-latex-name (apply-partially #'nth 1))
    (fset 'koek-ys/get-hunspell-name (apply-partially #'nth 2))
    (let ((map (mapcar (pcase-lambda (`(,ietf . ,spec))
                         (cons (koek-ys/get-org-name spec) ietf))
                       koek-ys/ietf-languages)))
      (fset 'koek-ys/org-to-ietf (lambda (org)
                                   (cdr (assoc org map)))))

    (defun koek-ys/make-ensure-result-directory (var-name)
      "Return function to ensure result directory of current source block exists.
  VAR-NAME is a string, the variable name which stores the result
  file name."
      (lambda ()
        (when-let (file-name
                   (when-let (value (koek-org/get-src-block-var-value var-name))
                     (file-name-directory
                      (replace-regexp-in-string (rx (or (and line-start "\"")
                                                        (and "\"" line-end)))
                                                "" value))))
          (when-let (root-file-name (buffer-file-name))
            (setq file-name
                  (expand-file-name file-name
                                    (file-name-directory root-file-name))))
          (when (file-name-absolute-p file-name)
            (make-directory file-name 'parents)))))

    ;; Load own snippets
    (setq yas-snippet-dirs (delq 'yas-installed-snippets-dir yas-snippet-dirs))
    (yas-reload-all)

    ;; Set new snippet file snippet
    (with-temp-buffer
      (insert-file-contents
       (expand-file-name "yasnippet/snippets/snippet-mode/new"
                         no-littering-etc-directory))
      (setq yas-new-snippet-default
            (buffer-substring (re-search-forward (rx line-start "# --\n"))
                              (point-max))))
    :delight yas-minor-mode)
#+END_SRC

** undo-tree - Undo & redo replacement
[[http://melpa.milkbox.net/#/undo-tree][undo-tree (Melpa)]]

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :demand t
    :bind
    (:map undo-tree-map
     ("M-/" . undo-tree-redo))
    :config
    (global-undo-tree-mode)
    :delight)
#+END_SRC

*** Issues

**** Restoring history fails
#+BEGIN_SRC emacs-lisp :tangle no
  (setq undo-tree-auto-save-history t)
#+END_SRC

When revisiting then modifying file, history is discarded.

** ispell - Spell checker
#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :defer t
    :config
    (setq ispell-program-name "hunspell")
    (let ((dictionary-name "en_US"))
      ;; On Windows, Hunspell requires the DICTIONARY environment
      ;; variable to be set
      (when (eq system-type 'windows-nt)
        (setenv "DICTIONARY" dictionary-name))
      (setq ispell-dictionary dictionary-name)))
#+END_SRC

** flycheck - Show syntax & style errors
[[https://github.com/flycheck/flycheck][flycheck (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :hook ((emacs-lisp-mode erlang-mode) . flycheck-mode)
    :delight)
#+END_SRC

*** flycheck-jslint - JSLint checker
[[https://github.com/Koekelas/jslint-cli][flycheck-jslint (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-jslint
    :load-path "lisp/jslint-cli/"
    :after (:all flycheck (:any js2-mode json-mode)))
#+END_SRC

* Windows & buffers

** ace-window - Jump to window
[[https://github.com/abo-abo/ace-window][ace-window (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :bind
    ([remap other-window] . ace-window)
    :config
    (setq aw-swap-invert t)
    (setq aw-keys '(?q ?s ?d ?f ?j ?k ?l ?m))
    (setq aw-dispatch-alist '((?o aw-flip-window)))
    (setq aw-leading-char-style 'path)
    ;; When there are two windows, Ace chooses the other window. When
    ;; there are three or more windows, Ace asks for a window. Enabling
    ;; background (default) differentiates both cases.
    ;; (setq aw-background nil)
    )
#+END_SRC

** winner - Undo & redo window layout changes
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :demand t
    :bind
    (("C-c w l" . winner-undo)
     ("C-c w r" . winner-redo))
    :config
    (winner-mode))
#+END_SRC

** eyebrowse - Workspaces
[[https://github.com/wasamasa/eyebrowse][eyebrowse (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :ensure t
    :bind
    (("C-c w 0" . eyebrowse-switch-to-window-config-0)
     ("C-c w 1" . eyebrowse-switch-to-window-config-1)
     ("C-c w 2" . eyebrowse-switch-to-window-config-2)
     ("C-c w 3" . eyebrowse-switch-to-window-config-3)
     ("C-c w 4" . eyebrowse-switch-to-window-config-4)
     ("C-c w 5" . eyebrowse-switch-to-window-config-5)
     ("C-c w 6" . eyebrowse-switch-to-window-config-6)
     ("C-c w 7" . eyebrowse-switch-to-window-config-7)
     ("C-c w 8" . eyebrowse-switch-to-window-config-8)
     ("C-c w 9" . eyebrowse-switch-to-window-config-9)
     ("C-c w w" . eyebrowse-last-window-config)
     ("C-c w k" . eyebrowse-close-window-config))
    :config
    ;; Resolve keybinding conflict with org
    (setq minor-mode-map-alist
          (assq-delete-all 'eyebrowse-mode minor-mode-map-alist))

    (setq eyebrowse-mode-line-style 'hide)
    (eyebrowse-mode))
#+END_SRC

** uniquify - Descriptive buffer names
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config
    (setq uniquify-buffer-name-style 'forward)
    (setq uniquify-trailing-separator-p t))
#+END_SRC

** ibuffer - list-buffers replacement
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind
    ([remap list-buffers] . ibuffer))
#+END_SRC

** Buffer commands
Bury unneeded buffers, computers have more than enough memory.

#+BEGIN_SRC emacs-lisp
  (defun koek-buff/bury (&optional arg)
    "Bury current.
  With `\\[universal-argument]' prefix argument ARG, kill current."
    (interactive "P")
    (if arg
        (kill-buffer)
      (bury-buffer)))

  (bind-key [remap kill-buffer] #'koek-buff/bury)
#+END_SRC

* Other

** Minibuffer
Enable minibuffer commands (e.g. [[*counsel - Ivy powered commands][counsel]]) in minibuffer.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

** ivy - completing-read replacement
[[https://github.com/abo-abo/swiper][ivy (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :demand t
    :bind
    (("C-r" . ivy-resume)
     :map ivy-minibuffer-map
     ("C-c j" . ivy-avy))
    :config
    (declare-function ivy-mode "ivy")

    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (counsel-ag . ivy--regex-plus)
            (counsel-unicode-char . ivy--regex-ignore-order)
            (t . ivy--regex-fuzzy)))
    (setq ivy-use-virtual-buffers t)
    (setq ivy-virtual-abbreviate 'full)
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-use-selectable-prompt t)
    (setq ivy-count-format "%d/%d ")
    (ivy-mode)
    :delight)
#+END_SRC

*** counsel - Ivy powered commands
[[https://github.com/abo-abo/swiper][counsel (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (([remap find-file] . counsel-find-file)
     ([remap insert-char] . counsel-unicode-char)
     ([remap isearch-forward] . counsel-grep-or-swiper)
     ([remap yank-pop] . counsel-yank-pop)
     ([remap execute-extended-command] . counsel-M-x)
     ([remap info-lookup-symbol] . counsel-info-lookup-symbol)
     ("C-M-s" . counsel-ag)
     ("C-c f s" . counsel-file-jump)
     ("C-c f l" . counsel-find-library)
     ("C-c j d" . counsel-imenu)
     ("C-c j o" . counsel-org-goto-all)
     :map minibuffer-local-map
     ("C-r" . counsel-minibuffer-history))
    :config
    (declare-function ivy-set-actions "ivy")

    (let ((show-help (lambda (candidate)
                       (helpful-function (intern candidate)))))
      (ivy-set-actions 'counsel-M-x
                       `(("d" counsel--find-symbol "definition")
                         ("h" ,show-help "help"))))

    (setq counsel-outline-face-style 'org))
#+END_SRC

*** counsel-projectile - Ivy powered Projectile commands
[[https://github.com/ericdanan/counsel-projectile][counsel-projectile (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :after projectile
    :config
    (setq counsel-projectile-key-bindings
          (append counsel-projectile-key-bindings
                  `((,(kbd "C-p") . counsel-projectile-switch-project)
                    (,(kbd "p")   . counsel-projectile))))

    (counsel-projectile-mode))
#+END_SRC

*** flx - Score candidates
[[https://github.com/lewang/flx][flx (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package flx
    :ensure t
    :after ivy)
#+END_SRC

** helpful - Help viewer
[[https://github.com/Wilfred/helpful][helpful (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    (([remap describe-variable] . helpful-variable)
     ([remap describe-function] . helpful-callable)
     ([remap describe-key] . helpful-key)))
#+END_SRC

** info - Info viewer
#+BEGIN_SRC emacs-lisp
  (use-package info
    :bind
    ("C-c d i" . info-apropos))
#+END_SRC

** apropos - Search Emacs environment
#+BEGIN_SRC emacs-lisp
  (use-package apropos
    :bind
    ("C-c d a" . apropos))
#+END_SRC

** devdocs-lookup - Search DevDocs
[[https://github.com/skeeto/devdocs-lookup][devdocs-lookup (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package devdocs-lookup
    :load-path "lisp/devdocs-lookup/"
    :bind
    ("C-c d d" . devdocs-lookup)
    :config
    (declare-function devdocs-setup "devdocs-lookup")

    (devdocs-setup))
#+END_SRC

** eldoc - Show docstring
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :commands eldoc-mode
    :delight)
#+END_SRC

** which-key - Show keybindings
[[https://github.com/justbur/emacs-which-key][which-key (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-add-key-based-replacements
      "C-c !" "errors"
      "C-c &" "yasnippet"
      "C-c d" "documentation"
      "C-c f" "files"
      "C-c j" "jump"
      "C-c o" "org"
      "C-c p" "projectile"
      "C-c r" "refactor"
      "C-c w" "windows"
      "C-c x" "other")

    ;; Resolve rename keybinding conflict with org
    (which-key-add-major-mode-key-based-replacements 'org-mode
      "C-c !" nil)

    (which-key-mode)
    :delight)
#+END_SRC

*** Issues

**** Sorting on description fails
#+BEGIN_SRC emacs-lisp :tangle no
  (setq which-key-sort-order 'which-key-description-order)
#+END_SRC

Prefix map =projectile= is sorted before prefix map =documentation=.

** eshell - Shell
#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :bind
    ("C-c x e" . eshell))

  (use-package esh-module
    :defer t
    :config
    (add-to-list 'eshell-modules-list 'eshell-smart))

  (use-package em-unix
    :defer t
    :config
    (setq eshell-mv-interactive-query t)
    (setq eshell-cp-interactive-query t)
    (setq eshell-ln-interactive-query t)
    (setq eshell-rm-interactive-query t))
#+END_SRC

** compile - Run asynchronous processes
#+BEGIN_SRC emacs-lisp
  (use-package compile
    :bind
    (("C-c x c" . compile)
     ("C-c x r" . recompile))
    :preface
    (declare-function ansi-color-apply-on-region "ansi-color")

    (defun koek-cmpl/style-output ()
      "Style output of process.
  Output is between compilation-filter-start and point."
      (ansi-color-apply-on-region compilation-filter-start (point)))
    :config
    (setq compilation-scroll-output 'first-error)
    (add-hook 'compilation-filter-hook #'koek-cmpl/style-output))
#+END_SRC

** wgrep - Edit files through grep output
[[https://github.com/mhayashi1120/Emacs-wgrep][wgrep (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t
    :defer t)
#+END_SRC

** elfeed - News reader
[[https://github.com/skeeto/elfeed][elfeed (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    ("C-c x n" . elfeed))

  (use-package elfeed-search
    :defer t
    :config
    (setq elfeed-search-filter (concat elfeed-search-filter " ")))
#+END_SRC

** calendar - Calendar
#+BEGIN_SRC emacs-lisp
  (use-package calendar
    :defer t
    :config
    (setq calendar-week-start-day 1))     ; Monday
#+END_SRC

* Languages

** Arduino
#+BEGIN_SRC emacs-lisp
  (defun koek-ino/get-in (keys alist)
    "Return value for KEYS in nested ALIST.
  KEYS is a list of keys."
    (if keys
        (koek-ino/get-in (cdr keys) (assq (car keys) alist))
      (cdr alist)))

  (defun koek-ino/set-in (keys value alist)
    "Set value for KEYS to VALUE in nested ALIST.
  KEYS is a list of keys."
    (when-let (key (car keys))
      (let ((pair (or (assq key alist)
                      (let ((new-pair (cons key ())))
                        (push new-pair alist)
                        new-pair))))
        (setcdr pair (if-let (rem-keys (cdr keys))
                         (koek-ino/set-in rem-keys value (cdr pair))
                       value))))
    alist)

  (defun koek-ino/extract-keys (compound-key)
    "Extract keys from COMPOUND-KEY.
  COMPOUND-KEY is a string of dot separated keys."
    (mapcar (lambda (key)
              (intern (concat ":" key)))
            (split-string compound-key (rx "."))))

  (defun koek-ino/make-nested-alist (properties)
    "Return nested alist.
  PROPERTIES is an alist of compound key to value pairs."
    (seq-reduce (pcase-lambda (alist `(,key . ,value))
                  (koek-ino/set-in (koek-ino/extract-keys key) value alist))
                properties ()))

  (defun koek-ino/read-properties (file-name)
    "Read properties from FILE-NAME."
    (let ((properties ()))
      (with-temp-buffer
        (insert-file-contents file-name)
        (while (re-search-forward         ; Matches across multiple lines
                (rx line-start
                    (submatch-n 1
                     (not (any "#\n")) (one-or-more (not (any "=")))) "="
                    (submatch-n 2 (one-or-more not-newline)) line-end)
                nil t)
          (push (cons (match-string 1) (match-string 2)) properties)))
      (koek-ino/make-nested-alist properties)))

  (defun koek-ino/read-hardware-specs (file-names)
    "Read hardware specifications from FILE-NAMES.
  FILE-NAMES is a list of file names to hardware specification
  install directories."
    (thread-last file-names
      (seq-mapcat
       (lambda (file-name)
         (file-expand-wildcards (expand-file-name "*/*/platform.txt" file-name)
                                'full)))
      (mapcar #'file-name-directory)
      (mapcar
       (lambda (file-name)
         `((:home        . ,file-name)
           (:boards      . ,(koek-ino/read-properties
                             (expand-file-name "boards.txt" file-name)))
           (:platform    . ,(koek-ino/read-properties
                             (expand-file-name "platform.txt" file-name)))
           (:programmers . ,(koek-ino/read-properties
                             (expand-file-name "programmers.txt" file-name))))))))

  (defun koek-ino/insert-section-heading (name)
    "Insert section heading into current.
  NAME is a string."
    (unless (= (point) 1)
      (insert "\n"))
    (insert "[" name "]\n"))

  (defun koek-ino/normalize-property-value (value)
    "Normalize property value VALUE.
  VALUE is a symbol, number, string or list.  Value is converted to
  a string."
    (cond
     ((listp value)
      (format "[%s]" (mapconcat #'koek-ino/normalize-property-value value ", ")))
     ((stringp value)
      (format "'%s'" value))
     (t
      (format "%s" value))))

  (defun koek-ino/insert-property (key value)
    "Insert property into current.
  KEY is a string.  VALUE is a symbol, number, string or list."
    (insert key " = " (koek-ino/normalize-property-value value) "\n"))

  (eval-and-compile
    (defun koek-ino/propertyp (element)
      "Return whether ELEMENT is a property."
      (not (keywordp element)))

    (defun koek-ino/normalize-sections-spec (spec &optional sections)
      "Normalize sections specification SPEC.
  SPEC is a list of section names and properties.  Specification is
  converted to a nested alist.  Keys are converted to strings.
  SECTIONS is used internally."
      (if spec
          (let ((section
                 (cons
                  (replace-regexp-in-string (rx line-start ":") ""
                                            (symbol-name (car spec)))
                  (mapcar (pcase-lambda (`(,key ,value))
                            (cons (symbol-name key) value))
                          (seq-partition
                           (seq-take-while #'koek-ino/propertyp (cdr spec)) 2)))))
            (koek-ino/normalize-sections-spec
             (seq-drop-while #'koek-ino/propertyp (cdr spec))
             (cons section sections)))
        (reverse sections))))

  (defmacro koek-ino/write-cross-file (file-name &rest spec)
    (declare (indent 1))
    `(with-temp-file ,file-name
       ,@(seq-mapcat (pcase-lambda (`(,name . ,properties))
                       (cons `(koek-ino/insert-section-heading ,name)
                             (mapcar (pcase-lambda (`(,key . ,value))
                                       `(koek-ino/insert-property ,key ,value))
                                     properties)))
                     (koek-ino/normalize-sections-spec spec))))

  (defconst koek-ino/hardware-install-dirs '("/usr/share/arduino/hardware/")
    "List of file names to hardware specification install directories.")

  (defconst koek-ino/hardware-whitelist-preds
    (list (lambda (spec)
            (let ((name (koek-ino/get-in '(:platform :name) spec))
                  (version (koek-ino/get-in '(:platform :version) spec)))
              (and (string= name "Arch Linux Arduino AVR Boards")
                   (string-match-p (rx line-start "1.6." (one-or-more num) line-end)
                                   version)
                   t))))
    "List of hardware specification whitelist predicates.
  Predicates are passed a hardware specification.  When a predicate
  returns t, the hardware specification is whitelisted.")

  (defun koek-ino/generate-project (file-name board-spec)
    "Generate Arduino project.
  FILE-NAME is a string, the file name to the project home
  directory.  BOARD-SPEC is an alist, the board specification.  It
  has two keys, :hardware and :board.  :hardware points to a
  hardware specification.  :board points to a board in :hardware."
    (interactive
     (list
      (thread-last (read-directory-name "Project home: ")
        expand-file-name
        file-name-as-directory)
      (let* ((hardware-specs
              (seq-filter
               (lambda (spec)
                 (seq-some (lambda (pred)
                             (funcall pred spec))
                           koek-ino/hardware-whitelist-preds))
               (koek-ino/read-hardware-specs koek-ino/hardware-install-dirs)))
             (candidates
              (seq-mapcat
               (lambda (hardware-spec)
                 (let ((platform-name
                        (format
                         "%s %s"
                         (koek-ino/get-in '(:platform :name) hardware-spec)
                         (koek-ino/get-in '(:platform :version) hardware-spec))))
                   (thread-last (koek-ino/get-in '(:boards) hardware-spec)
                     (mapcar #'cdr)
                     (seq-filter (apply-partially #'koek-ino/get-in '(:name)))
                     (mapcar (lambda (board-spec)
                               (cons (format "%s (%s)"
                                             (koek-ino/get-in '(:name) board-spec)
                                             platform-name)
                                     `((:board    . ,board-spec)
                                       (:hardware . ,hardware-spec))))))))
               hardware-specs)))
        (cdr (assoc (completing-read "Board: " candidates nil t) candidates)))))
    (make-directory file-name 'parents)
    (koek-ino/write-cross-file (expand-file-name "cross.txt" file-name)
      :binaries
      c (executable-find "avr-gcc")
      cpp (executable-find "avr-g++")
      :properties
      ino_src (directory-files
               (thread-last (koek-ino/get-in '(:hardware :home) board-spec)
                 (expand-file-name "cores/")
                 (expand-file-name
                  (koek-ino/get-in '(:board :build :core) board-spec))
                 file-name-as-directory)
               'full (rx (or ".c" ".cpp") line-end))
      :host_machine
      system "bare"))
#+END_SRC

** C family
#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :mode
    (((rx ".c" string-end) . c-mode)
     ((rx ".cpp" string-end) . c++-mode)
     ((rx ".java" string-end) . java-mode))
    :config
    (use-package devdocs-lookup
      :bind
      (:map c-mode-map
       ("C-c d d" . devdocs-lookup-c)
       :map c++-mode-map
       ("C-c d d" . devdocs-lookup-cpp))))

  (use-package cc-cmds
    :defer t
    :preface
    (define-advice
        c-update-modeline (:around (f) koek-cc/disable-update-mode-name)
      (let ((name mode-name))
        (funcall f)
        (setq mode-name name))))

  (use-package cc-vars
    :defer t
    :config
    (setq c-default-style
          '((awk-mode  . "awk")
            (java-mode . "java")
            (other     . "stroustrup"))))
#+END_SRC

** Clojure & ClojureScript
[[https://github.com/clojure-emacs/clojure-mode][clojure-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure t
    :mode
    (((rx ".clj" string-end) . clojure-mode)
     ((rx ".cljs" string-end) . clojurescript-mode))
    :delight
    (clojure-mode "Clj" :major)
    (clojurescript-mode "Cljs" :major))
#+END_SRC

*** cider - Interact with process
[[https://github.com/clojure-emacs/cider][cider (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t
    :after clojure-mode)

  (use-package cider-mode
    :defer t
    :delight)

  (use-package cider-common
    :defer t
    :config
    (setq cider-prompt-for-symbol nil))

  (use-package cider-repl
    :defer t
    :config
    (setq cider-repl-use-pretty-printing t))
#+END_SRC

** Common Lisp
#+BEGIN_SRC emacs-lisp
  (use-package lisp-mode
    :mode (rx ".lisp" string-end))

  (use-package inf-lisp
    :after lisp-mode
    :config
    (setq inferior-lisp-program "sbcl"))
#+END_SRC

** Emacs Lisp
#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :mode ((rx ".el" string-end) . emacs-lisp-mode)
    :config
    (use-package pp
      :bind
      (:map emacs-lisp-mode-map
       ("C-c x p" . pp-eval-last-sexp)
       ("C-c x m" . pp-macroexpand-last-sexp)
       :map lisp-interaction-mode-map
       ("C-c x p" . pp-eval-last-sexp)
       ("C-c x m" . pp-macroexpand-last-sexp)))

    (use-package helpful
      :bind
      (:map emacs-lisp-mode-map
       ("C-c C-d" . helpful-at-point)
       :map lisp-interaction-mode-map
       ("C-c C-d" . helpful-at-point)))
    :delight (emacs-lisp-mode "El" :major))
#+END_SRC

** Erlang
[[https://github.com/erlang/otp][erlang (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package erlang
    :ensure t
    :mode ((rx ".erl" string-end) . erlang-mode)
    :config
    ;; On Windows, executable-find finds the erlc shim. Shadow
    ;; c:/ProgramData/chocolatey/bin/.
    (when-let
        (erlc-program-name
         ;; Assume only one version installed
         (car (file-expand-wildcards "c:/Program Files/erl*/bin/erlc.exe" 'full)))
      (push (file-name-directory erlc-program-name) exec-path))
    (when-let (erlc-program-name (executable-find "erlc"))
      (setq erlang-root-dir
            (locate-dominating-file (file-truename erlc-program-name) "bin")))
    :delight (erlang-mode "Erl" :major))
#+END_SRC

** HTML & CSS
#+BEGIN_SRC emacs-lisp
  (use-package mhtml-mode
    :mode (rx (or ".htm" ".html") string-end)
    :config
    (use-package devdocs-lookup
      :bind
      (:map mhtml-mode-map
       ("C-c d d" . devdocs-lookup-html)))
    :delight (mhtml-mode "HTML" :major))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode (rx ".css" string-end))
#+END_SRC

*** emmet - Expand selector to HTML or CSS
[[https://github.com/smihica/emmet-mode][emmet-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :bind
    (:map emmet-mode-keymap
     ("C-<tab>" . emmet-expand-line))     ; Why does <tab> work but TAB not?
    :hook (mhtml-mode css-mode)
    :config
    (setq emmet-self-closing-tag-style " /")
    :delight)
#+END_SRC

** JavaScript
[[https://github.com/mooz/js2-mode][js2-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode (rx ".js" string-end)
    :interpreter "node"
    :config
    (use-package devdocs-lookup
      :bind
      (:map js2-mode-map
       ("C-c d d" . devdocs-lookup-javascript)
       ("C-c d C-d" . devdocs-lookup-dom)
       ("C-c d C-e" . devdocs-lookup-dom_events)
       ("C-c d C-j" . devdocs-lookup-jquery)
       ("C-c d C-l" . devdocs-lookup-lodash)
       ("C-c d C-n" . devdocs-lookup-node)
       ("C-c d C-x" . devdocs-lookup-express)))

    ;; Resolve keybinding conflict with eglot
    (unbind-key "M-." js2-mode-map)

    (setq js2-mode-show-parse-errors nil)
    (setq js2-mode-show-strict-warnings nil)
    :delight (js2-mode "JS" :major))
#+END_SRC

*** indium - Interact with process
[[https://github.com/NicolasPetton/Indium][indium (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package indium
    :ensure t
    :defer t)

  (use-package indium-interaction
    :hook (js2-mode . indium-interaction-mode)
    :config
    ;; Resolve keybinding conflict with documentation keymap
    (unbind-key "C-c d" indium-interaction-mode-map)
    :delight)
#+END_SRC

** JSON
[[https://github.com/joshwnj/json-mode][json-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :mode (rx ".json" string-end)
    :config
    (use-package devdocs-lookup
      :bind
      (:map json-mode-map
       ("C-c d C-n" . devdocs-lookup-npm))))
#+END_SRC

** Markdown
[[https://github.com/jrblevin/markdown-mode][markdown-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (rx ".md" string-end)
    :config
    (setq markdown-command "pandoc -s -f markdown -t html5")
    (setq markdown-use-pandoc-style-yaml-metadata t)
    (setq markdown-asymmetric-header t)
    :delight (markdown-mode "MD" :major))
#+END_SRC

** Meson
[[https://github.com/wentasah/meson-mode][meson-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package meson-mode
    :ensure t
    :mode (rx "meson.build" string-end))
#+END_SRC

*** Issues

**** Code fails to complete
See [[https://github.com/wentasah/meson-mode/issues/16][Issue 16 (GitHub)]].

** Octave & MATLAB

#+BEGIN_SRC emacs-lisp
  (use-package octave
    :mode ((rx ".m" string-end) . octave-mode)
    :config
    ;; Insert MATLAB compatible comments
    (setq octave-comment-char ?%)
    (setq octave-comment-start (char-to-string octave-comment-char))
    (setq octave-block-comment-start
          (concat (make-string 2 octave-comment-char) " "))

    (setq octave-blink-matching-block nil)
    :delight (octave-mode "M" :major))
#+END_SRC

*** Issues

**** Eldoc fails to show docstring
It fails with error:

#+BEGIN_SRC fundamental
  alnum:]][[:alnum:]\-]*)({ <-- HERE })?\s*/ at /usr/share/texinfo/Texinfo/Parser.pm line 5481. | alnum:]][[:alnum:]\-]*)({ <-- HERE })?\s*(\@(c|comment)((\@|\s+).*)?)?/ at /usr/share/texinfo/Texinfo/Parser.pm line 5485.
#+END_SRC

** OpenSCAD
[[https://github.com/openscad/openscad][scad-mode (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package scad-mode
    :ensure t
    :mode (rx ".scad" string-end)
    :config
    ;; Resolve smartparens' delayed post handlers not being called
    (unbind-key "<return>" scad-mode-map) ; Why does <return> differ from RET?

    (setq scad-indent-style "stroustrup"))
#+END_SRC

*** Issues

**** Built-in indentation styles are inappropriate for multiple line vectors
See [[info:ccmode#Customizing%20Indentation][Customizing Indentation (info)]].

** Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :mode ((rx ".org" string-end) . org-mode)
    :bind
    (("C-c o l" . org-store-link)
     :map org-mode-map
     ("C-M-f" . org-forward-heading-same-level)
     ("C-M-b" . org-backward-heading-same-level)
     ("C-M-n" . org-next-visible-heading)
     ("C-M-p" . org-previous-visible-heading)
     ("C-M-a" . org-previous-block)
     ("C-M-e" . org-next-block))
    :preface
    (declare-function org-clock-persistence-insinuate "org")

    (defun koek-org/setup-tag-completion ()
      "Setup tag completion for current.
  Candidates are collected from agenda files."
      (setq-local org-complete-tags-always-offer-all-agenda-tags t))

    ;; Setup resume clock after showing initial buffer
    (add-hook 'window-setup-hook #'org-clock-persistence-insinuate)
    :config
    (declare-function org-babel-do-load-languages "org")
    (declare-function org-redisplay-inline-images "org")

    (use-package avy
      :bind
      (:map org-mode-map
       ("C-c j h" . avy-org-goto-heading-timer)))

    (use-package counsel
      :bind
      (:map org-mode-map
       ([remap org-set-tags-command] . counsel-org-tag)))

    (use-package org-clock
      :bind
      (:map org-mode-map
       ("C-c o i" . org-clock-in)))

    (use-package outline
      :bind
      (:map org-mode-map
       ("C-M-u" . outline-up-heading)))

    ;; Headings, keywords & tags
    (setq org-outline-path-complete-in-steps nil)
    (setq org-refile-use-outline-path 'buffer-name)
    (setq org-todo-keywords
          '((sequence "TODO(t)" "STALLED(s@/!)" "|" "DONE(d!)" "ABANDONED(a@)")))
    (add-hook 'org-capture-mode-hook #'koek-org/setup-tag-completion)

    ;; Other
    (setq org-keep-stored-link-after-insertion t)
    (org-babel-do-load-languages 'org-babel-load-languages
                                 '((C . t) ; C and C++
                                   (clojure . t)
                                   (lisp . t)
                                   (emacs-lisp . t)
                                   (java . t)
                                   (js . t)
                                   (octave . t)
                                   (python . t)
                                   (scheme . t)
                                   (sql . t)))

    ;; Appearance
    (setq org-adapt-indentation nil)

    ;; Appearance - Images
    (setq org-startup-with-inline-images t)
    (let ((width (thread-last (display-monitor-attributes-list)
                   car                   ; Primary display
                   (alist-get 'workarea) ; Arrangement/resolution without taskbar
                   (nth 2))))            ; Width
      (setq org-image-actual-width (floor (* width (/ 1 3.0)))))
    (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)

    ;; Appearance - LaTeX previews
    (setq org-startup-with-latex-preview t)
    (setq org-preview-latex-image-directory
          (no-littering-expand-var-file-name "org/latex-previews/"))
    (setq org-format-latex-options
          (plist-put org-format-latex-options :scale (/ 4 3.0)))

    ;; Appearance - Export
    (add-to-list 'org-latex-packages-alist '("" "listings" t)))

  (use-package org-agenda
    :bind
    ("C-c o a" . org-agenda)
    :config
    (use-package counsel
      :bind
      (:map org-agenda-mode-map
       ([remap org-agenda-set-tags] . counsel-org-tag-agenda)))

    (setq org-agenda-time-leading-zero t))

  (use-package org-capture
    :bind
    ("C-c o c" . org-capture))

  (use-package org-clock
    :bind
    (("C-c j c" . org-clock-goto)
     ("C-c o o" . org-clock-out)
     ("C-c o x" . org-clock-cancel))
    :config
    (declare-function org-clock-load "org-clock")

    (setq org-clock-persist 'clock)

    (org-clock-load))

  (use-package org-src
    :bind
    (:map org-src-mode-map
     ("C-c o '" . org-edit-src-exit)
     ("C-c o k" . org-edit-src-abort))
    :preface
    (defconst koek-org/excluded-checkers
      '((emacs-lisp-mode . (emacs-lisp-checkdoc)))
      "Alist of excluded checker pairs.
  Excluded checker pair is a cons. Its car is a major mode symbol,
  its cdr is a list of checker symbols.")

    (defun koek-org/disable-excluded-checkers ()
      "Disable excluded checkers for current."
      (dolist (checker (alist-get major-mode koek-org/excluded-checkers))
        (unless (memq checker flycheck-disabled-checkers)
          (push checker flycheck-disabled-checkers))))
    :config
    ;; Resolve keybinding conflict with cider
    (unbind-key "C-c '" org-src-mode-map)
    (unbind-key "C-c C-k" org-src-mode-map)

    (add-to-list 'org-src-lang-modes '("js" . js2))
    (add-hook 'org-src-mode-hook #'koek-org/disable-excluded-checkers)
    :delight)

  (use-package ob-core
    :defer t
    :config
    (declare-function org-babel-get-src-block-info "ob-core")

    (defun koek-org/get-src-block-var-value (var-name)
      "Return value of variable VAR-NAME in current source block.
  VAR-NAME is a string, the variable name."
      (thread-last (org-babel-get-src-block-info 'light)
        (nth 2)                           ; Header arguments
        (seq-filter (pcase-lambda (`(,type))
                      (eq type :var)))
        (mapcar (pcase-lambda (`(,_type . ,value))
                  ;; Variable value could include "=" (e.g. :var
                  ;; foo="bar=baz")
                  (let ((pos (string-match-p "=" value)))
                    (cons (substring value 0 pos) (substring value (1+ pos))))))
        (seq-filter (pcase-lambda (`(,name))
                      (string= name var-name)))
        cdar))

    ;; Evaluate code blocks in buffer after confirmation
    (let ((whitelist ()))
      (setq org-confirm-babel-evaluate
            (lambda (_language _body)
              (let ((id (or (buffer-file-name) (buffer-name))))
                (unless (assoc id whitelist)
                  (push (cons id
                              (yes-or-no-p
                               (format "Evaluate code blocks in %s on your system this session? "
                                       id)))
                        whitelist))
                (not (cdr (assoc id whitelist))))))))

  (use-package ob-clojure
    :defer t
    :config
    (setq org-babel-clojure-backend 'cider))

  (use-package ox
    :defer t
    :config
    (setq org-export-headline-levels 4)
    (setq org-export-with-author nil)
    (setq org-export-with-date nil)
    (setq org-export-with-toc 3))

  (use-package ox-latex
    :defer t
    :config
    (setq org-latex-pdf-process '("latexmk -pdf %f"))
    (setq org-latex-listings t))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ((rx ".py" string-end) . python-mode)
    :preface
    (declare-function python-flymake "python")

    (defun koek-py/disable-checker ()
      "Disable Python checker for current."
      (remove-hook 'flymake-diagnostic-functions #'python-flymake 'local))
    :config
    (add-hook 'python-mode-hook #'koek-py/disable-checker)
    :delight (python-mode "Py" :major))
#+END_SRC

*** pipenv - Consume packages
[[https://github.com/pwalsh/pipenv.el][pipenv (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package pipenv
    :ensure t
    :hook (python-mode . pipenv-mode)
    :delight)
#+END_SRC

** Scheme
#+BEGIN_SRC emacs-lisp
  (use-package scheme
    :mode ((rx ".scm" string-end) . scheme-mode)
    :delight
    (scheme-mode
     (:eval
      (if geiser-impl--implementation
          (capitalize (symbol-name geiser-impl--implementation))
        "Scm"))
     :major))
#+END_SRC

*** geiser - Interact with process
[[https://github.com/jaor/geiser][geiser (GitHub)]]

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :ensure t
    :after scheme)

  (use-package geiser-autodoc
    :defer t
    :delight)

  (use-package geiser-impl
    :defer t
    :config
    (setq geiser-default-implementation 'guile))

  (use-package geiser-mode
    :defer t
    :delight)

  (use-package geiser-repl
    :defer t
    :config
    (setq geiser-repl-query-on-exit-p t))
#+END_SRC

** SQL
#+BEGIN_SRC emacs-lisp
  (use-package sql
    :mode ((rx ".sql" string-end) . sql-mode)
    :preface
    ;; When SQL dialect is setup, whitespace-mode faces are overridden
    (define-advice sql-mode (:around (f) koek-sql/defer-whitespace-mode)
      (let ((prog-mode-hook               ; Dynamic variable
             (remq 'whitespace-mode prog-mode-hook)))
        (funcall f)))

    (define-advice
        sql-highlight-product (:around (f) koek-sql/re-enable-whitespace-mode)
      (whitespace-mode 0)
      (funcall f)
      (whitespace-mode))

    ;; When SQL dialect is setup, mode-name is overridden (i.e. delight
    ;; is undone)
    (define-advice sql-highlight-product (:after () koek-sql/update-mode-name)
      (setq mode-name
            '(:eval
              ;; When mode-name is evaluated outside mode line,
              ;; inhibit-mode-name-delight is truthy
              (if (or inhibit-mode-name-delight (eq sql-product 'ansi))
                  "SQL"
                (sql-get-product-feature sql-product :name)))))
    :config
    (use-package devdocs-lookup
      :bind
      (:map sql-mode-map
       ("C-c d C-p" . devdocs-lookup-postgresql)))

    (setq sql-product 'postgres))
#+END_SRC

*** sql-indent - Indent code
#+BEGIN_SRC emacs-lisp
  (use-package sql-indent
    :ensure t
    :hook (sql-mode . sqlind-minor-mode)
    :delight sqlind-minor-mode)
#+END_SRC

** Text
#+BEGIN_SRC emacs-lisp
  (use-package text-mode
    :mode (rx (or ".txt" "/README" "/LICENSE") string-end)
    :preface
    ;; See https://github.com/jwiegley/use-package/issues/267
    (provide 'text-mode)
    :delight (text-mode "Txt" :major))
#+END_SRC

** Conf
Conf mode's mode declaration requires precedence over Text mode's.
Configure Conf mode after Text mode.

#+BEGIN_SRC emacs-lisp
  (use-package conf-mode
    :mode (rx "cross.txt" string-end)
    :preface
    (defconst koek-conf/mode-names
      '((conf-unix-mode . "Unix"))
      "Alist of Conf mode symbol to Conf mode name pairs.")

    (define-advice
        conf-mode-initialize (:after (&rest _args) koek-conf/update-mode-name)
      (setq mode-name
            '(:eval
              (or (and (not inhibit-mode-name-delight)
                       (alist-get major-mode koek-conf/mode-names))
                  "Conf")))))
#+END_SRC

** YASnippet
For the minor mode, see [[*yasnippet - Snippets][yasnippet - Snippets]].

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :mode ("/snippets/" . snippet-mode))
#+END_SRC

* Appearance
Maximize frames.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

Show file name in title bar.

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
        '((:eval
           (let ((file-name (buffer-file-name)))
             (cond
              ((and (projectile-project-p) file-name)
               (format "~%s/%s"
                       (projectile-project-name)
                       (file-relative-name file-name (projectile-project-root))))
              (file-name
               (abbreviate-file-name file-name))
              (t
               "%b"))))
          " - Emacs"))
#+END_SRC

Disable menu bar, tool bar and scroll bars.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
#+END_SRC

Load [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow]] theme.

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t
    :preface
    (declare-function color-rgb-to-hex "color")

    (defun koek-thm/set-dark-wm-theme-variant (frame)
      "Set window manager theme variant of FRAME to dark."
      (call-process "xprop" nil nil nil
                    "-id" (frame-parameter frame 'outer-window-id)
                    "-f" "_GTK_THEME_VARIANT" "8u"
                    "-set" "_GTK_THEME_VARIANT" "dark"))

    (defun koek-thm/mix (color1 color2 &optional ratio)
      "Mix COLOR1 with COLOR2 according to RATIO.
  COLOR1 and COLOR2 are strings, a color name or an RGB triplet,
  see `color-name-to-rgb'.  Optional RATIO is a float from zero to
  one and defaults to one half.  Zero means mix zero units of
  COLOR1 with one unit of COLOR2, one means mix one unit of COLOR1
  with zero units of COLOR2."
      (unless ratio
        (setq ratio 0.5))
      (let ((ratio´ (- 1 ratio)))
        (apply #'color-rgb-to-hex
               (seq-mapn (lambda (component component´)
                           (+ (* component ratio) (* component´ ratio´)))
                         (color-name-to-rgb color1) (color-name-to-rgb color2)))))
    :config
    ;; Set frame (i.e. window manager) theme
    (when (executable-find "xprop")
      (koek-thm/set-dark-wm-theme-variant (selected-frame))
      (add-hook 'after-make-frame-functions #'koek-thm/set-dark-wm-theme-variant))

    ;; Set window theme
    (load-theme 'sanityinc-tomorrow-eighties 'no-confirm)
    (let* ((theme (alist-get 'eighties color-theme-sanityinc-tomorrow-colors))
           (personal
            (map-let (foreground background yellow green aqua blue) theme
              `((alt-bg    . ,(koek-thm/mix background foreground 0.98))
                (lc-fg     . ,(koek-thm/mix foreground background))
                (lc-yellow . ,(koek-thm/mix yellow background))
                (lc-green  . ,(koek-thm/mix green background))
                (lc-aqua   . ,(koek-thm/mix aqua background))
                (lc-blue   . ,(koek-thm/mix blue background)))))
           (specs
            (map-let                      ; How to use let-alist and backquote?
                (foreground background current-line selection comment red orange
                 aqua alt-bg lc-fg lc-yellow lc-green lc-aqua lc-blue)
                (append personal theme)
              `(;; Default
                (show-paren-match    :foreground ,foreground :background ,selection)
                (show-paren-mismatch :foreground ,foreground :background unspecified
                                     :underline (:style wave :color ,red))
                (header-line :inherit unspecified
                             :foreground ,aqua :background unspecified
                             :box ,selection)
                (fringe :foreground ,comment :background ,alt-bg)
                (mode-line          :foreground ,foreground :background ,current-line
                                    :underline ,selection :overline ,selection
                                    :box unspecified :weight unspecified)
                (mode-line-inactive :inherit unspecified
                                    :foreground ,comment :background ,alt-bg
                                    :underline ,selection :overline ,selection
                                    :weight unspecified)
                (mode-line-emphasis :foreground ,orange :slant unspecified)
                ;; rainbow-delimiters
                (rainbow-delimiters-depth-1-face :foreground ,lc-fg)
                (rainbow-delimiters-depth-2-face :foreground ,lc-aqua)
                (rainbow-delimiters-depth-3-face :foreground ,lc-yellow)
                (rainbow-delimiters-depth-4-face :foreground ,lc-green)
                (rainbow-delimiters-depth-5-face :foreground ,lc-blue)
                (rainbow-delimiters-depth-6-face :foreground ,lc-fg)
                (rainbow-delimiters-depth-7-face :foreground ,lc-aqua)
                (rainbow-delimiters-depth-8-face :foreground ,lc-yellow)
                (rainbow-delimiters-depth-9-face :foreground ,lc-green)
                (rainbow-delimiters-unmatched-face :inherit show-paren-mismatch
                                                   :foreground unspecified)
                ;; whitespace
                (whitespace-trailing :foreground unspecified :background ,selection)
                (whitespace-empty    :foreground unspecified :background ,selection)
                (whitespace-line     :foreground unspecified :background ,selection)
                ;; ace-window
                (aw-leading-char-face :inherit avy-lead-face
                                      :foreground unspecified)
                (aw-background-face :foreground ,lc-fg :background ,background)
                ;; eyebrowse
                (eyebrowse-mode-line-active :inherit mode-line-emphasis
                                            :foreground unspecified
                                            :weight unspecified)))))
      ;; Adding attributes to a face before it's defined, fails. Add
      ;; attributes to user theme.
      (apply #'custom-set-faces
             (mapcar (pcase-lambda (`(,name . ,attribs))
                       `(,name ((t . ,attribs))))
                     specs))))
#+END_SRC

Set default font. Try [[https://www.fsd.it/shop/fonts/pragmatapro/][PragmataPro Mono]], then [[https://adobe-fonts.github.io/source-code-pro/][Source Code Pro]].

#+BEGIN_SRC emacs-lisp
  (when-let
      (spec
       (seq-find (lambda (spec)
                   (member (plist-get spec :family) (font-family-list)))
                 '((:family "PragmataPro Mono" :size 15)
                   (:family "Source Code Pro"  :size 15))))
    (set-frame-font (apply #'font-spec spec) nil t))
#+END_SRC

Disable blink cursor mode, instead, enable highlight line mode.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (global-hl-line-mode)
#+END_SRC

Show:

- memory full indicator
- function arguments
- variant name and diff status
- edit depth
- input name
- workspace names
- project name, buffer name and buffer status
- narrowed indicator, percentage buffer above first visible line, line
  number and column number
- clocked time
- version control name and branch name
- checker name, number of errors and number of warnings
- major name, process status and minor names

in mode line.

#+BEGIN_SRC emacs-lisp
  (defconst koek-ml/separator "   "
    "Mode line group separator.")

  (defconst koek-ml/ediff
    '((eldoc-mode-line-string
       nil)
      (:eval
       (let* ((diff-n (1+ ediff-current-difference))
              (n-diffs ediff-number-of-differences)
              (right (concat (cond
                              ((< diff-n 1)
                               (format "Start -/%d" n-diffs))
                              ((> diff-n n-diffs)
                               (format "End -/%d" n-diffs))
                              (t
                               (format "%d/%d" diff-n n-diffs)))
                             koek-ml/separator
                             "(Ediff) ")))
         `((,(max 0 (- (window-total-width) (string-width right)))
            (" "
             (eldoc-mode-line-string
              ("" eldoc-mode-line-string koek-ml/separator))
             (:propertize "%b" face mode-line-buffer-id)
             koek-ml/separator))
           ,right))))
    "List of mode line constructs for ediff control buffer.")

  (defvar-local koek-ml/variant-name nil
    "Name of variant.")

  (defvar-local koek-ml/diff-status nil
    "Status of current diff.")

  (defun koek-ml/variants ()
    "Return variants of current ediff session."
    (seq-filter (lambda (variant)
                  (bufferp (cdr variant)))
                `(("A" . ,ediff-buffer-A)
                  ("B" . ,ediff-buffer-B)
                  ("C" . ,ediff-buffer-C)
                  ("Ancestor" . ,ediff-ancestor-buffer))))

  (defun koek-ml/diff-status ()
    "Return status of current diff."
    (let ((status (nth 1 mode-line-format)))
      (when (symbolp status)
        (setq status (symbol-value status)))
      (unless (string= status "")
        (replace-regexp-in-string (rx (or (and line-start "[")
                                          (and "] " line-end)))
                                  "" status))))

  (define-advice ediff-refresh-mode-lines (:after () koek-ml/update-ediff)
    (setq mode-line-format koek-ml/ediff)
    (save-current-buffer
      (dolist (variant (koek-ml/variants))
        (set-buffer (cdr variant))
        (setq koek-ml/variant-name (car variant))
        (setq koek-ml/diff-status (koek-ml/diff-status))
        (ediff-strip-mode-line-format))))

  (defun koek-ml/cleanup-ediff ()
    "Cleanup ediff mode line variables."
    (save-current-buffer
      (dolist (variant (koek-ml/variants))
        (set-buffer (cdr variant))
        (kill-local-variable 'koek-ml/variant-name)
        (kill-local-variable 'koek-ml/diff-status))))

  (add-hook 'ediff-cleanup-hook #'koek-ml/cleanup-ediff)

  (declare-function eyebrowse--get "eyebrowse")

  (defun koek-ml/workspaces ()
    "Return workspaces of current frame."
    (eyebrowse--get 'window-configs))

  (defun koek-ml/current-workspace-id ()
    "Return workspace id of current frame."
    (eyebrowse--get 'current-slot))

  (defun koek-ml/workspace-id (workspace)
    "Return id of WORKSPACE."
    (car workspace))

  (defun koek-ml/workspace-name (workspace)
    "Return name of WORKSPACE."
    (let ((name (nth 2 workspace)))
      (unless (string= name "")
        name)))

  (defconst koek-ml/roman-numerals
    '((9 . "IX")
      (5 . "V")
      (4 . "IV")
      (1 . "I"))
    "Alist of sorted Arabic numeral to Roman numeral pairs.")

  (defun koek-ml/arabic-to-roman (n &optional roman-numerals)
    "Convert Arabic number N to Roman number.
  N is an integer greater than zero.  Optional ROMAN-NUMERALS is an
  alist of sorted Arabic numeral to Roman numeral pairs and
  defaults to `koek-ml/roman-numerals'."
    (unless roman-numerals
      (setq roman-numerals koek-ml/roman-numerals))
    (when (> n 0)
      (pcase-let ((`(,arabic . ,roman) (car roman-numerals)))
        (if (>= n arabic)
            (concat roman (koek-ml/arabic-to-roman (- n arabic) roman-numerals))
          (koek-ml/arabic-to-roman n (cdr roman-numerals))))))

  (defun koek-ml/workspace-label (workspace)
    "Return label of WORKSPACE.
  Label is made of a workspace id and name."
    (let ((id (or (koek-ml/arabic-to-roman (koek-ml/workspace-id workspace))
                  ;; Roman numeral zero doesn't exist. N stands for
                  ;; nulla, which means zero.
                  "N"))
          (name (koek-ml/workspace-name workspace)))
      (if name
          (format "%s:%s" id name)
        id)))

  (defconst koek-ml/checker-names
    '((emacs-lisp . "El")
      (emacs-lisp-checkdoc . "Checkdoc")
      (erlang . "Erlc")
      (html-tidy . "Tidy")
      (javascript-jslint . "JSLint"))
    "Alist of checker symbol to checker name pairs.")

  (declare-function flycheck-get-checker-for-buffer "flycheck")

  (defun koek-ml/checker-name ()
    "Return name of current checker."
    (when-let (checker (flycheck-get-checker-for-buffer))
      (or (alist-get checker koek-ml/checker-names) "Checker")))

  (defconst koek-ml/left
    '(" "
      (memory-full
       ("Memory Full!" koek-ml/separator))
      (eldoc-mode-line-string
       ("" eldoc-mode-line-string koek-ml/separator))
      (koek-ml/variant-name
       ((:propertize koek-ml/variant-name face mode-line-emphasis)
        (koek-ml/diff-status
         (" " koek-ml/diff-status))
        koek-ml/separator))
      (:eval
       (let ((depth (- (recursion-depth) (minibuffer-depth))))
         (when (> depth 0)
           (format "[%d]%s" depth koek-ml/separator))))
      (current-input-method
       ("" current-input-method-title koek-ml/separator))
      (:eval
       (when eyebrowse-mode
         (let ((workspaces (koek-ml/workspaces))
               (current-id (koek-ml/current-workspace-id)))
           (when (and workspaces
                      (or (> (length workspaces) 1) (not (= current-id 1))))
             (concat
              (mapconcat
               (lambda (workspace)
                 (let ((label (koek-ml/workspace-label workspace)))
                   (when (= (koek-ml/workspace-id workspace) current-id)
                     (setq label
                           (propertize label 'face 'eyebrowse-mode-line-active)))
                   label))
               workspaces " ")
              koek-ml/separator)))))
      ((:eval
        (when (projectile-project-p)
          (concat (projectile-project-name) "/")))
       (:propertize "%b" face mode-line-buffer-id)
       " %*%+"))
    "List of mode line constructs shown left.")

  (defconst koek-ml/right
    '(((:eval
        (when (buffer-narrowed-p)
          (concat (propertize "Narrowed" 'face 'mode-line-emphasis) " ")))
       "%p"
       " %l,%c"
       koek-ml/separator)
      (:eval
       (when (org-clock-is-active)
         (concat (org-duration-from-minutes (org-clock-get-clocked-time))
                 koek-ml/separator)))
      (:eval
       (when vc-mode
         (let ((status (substring-no-properties vc-mode)))
           (string-match (rx (submatch-n 1 (one-or-more alnum))
                             (zero-or-one ":" (one-or-more alnum))
                             (any "-:@!?")
                             (submatch-n 2 (one-or-more not-newline)))
                         status)
           (format "%s %s%s"
                   (match-string 1 status) (match-string 2 status)
                   koek-ml/separator))))
      (:eval
       (when flycheck-mode
         (concat (pcase flycheck-last-status-change
                   (`running
                    (format "%s - -" (koek-ml/checker-name)))
                   (`finished
                    (let-alist (flycheck-count-errors flycheck-current-errors)
                      (format "%s %d %d"
                              (koek-ml/checker-name)
                              (or .error 0) (or .warning 0))))
                   (`,status
                    (capitalize
                     (replace-regexp-in-string "-" " " (symbol-name status)))))
                 koek-ml/separator)))
      ("(" mode-name mode-line-process minor-mode-alist ")")
      " ")
    "List of mode line constructs shown right.")

  (setq-default mode-line-format
                '(;; Prevent eldoc from modifying mode-line-format
                  (eldoc-mode-line-string
                   nil)
                  (:eval
                   (let* ((inhibit-mode-name-delight nil) ; Dynamic variable
                          (right (format-mode-line koek-ml/right)))
                     `((,(max 0 (- (window-total-width) (string-width right)))
                        ("" koek-ml/left koek-ml/separator))
                       ;; Escape %'s
                       ,(replace-regexp-in-string "%" "%%" right))))))
#+END_SRC

* Footer
#+BEGIN_SRC emacs-lisp
  ;;; 50-general.el ends here
#+END_SRC
